# -*- coding: utf-8 -*-
"""Copy of Capstone Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PLKGA9UNQs6yV0uzB_xbQmpc8gB0VJNg
"""

# Import library yang diperlukan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from google.colab import files
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
import warnings
warnings.filterwarnings('ignore')

# Set style plot
plt.style.use('ggplot')
sns.set(style="whitegrid")
plt.rcParams['figure.figsize'] = (12, 8)

# Membaca dataset
indonesia_food_df = pd.read_csv('indonesiaFoodandDrink.csv')
nutrition_df = pd.read_csv('nutritionDataset.csv')
recipe_df = pd.read_csv('Food Ingredients and Recipe Dataset with Image Name Mapping.csv')

# Melihat informasi umum dataset
print("=" * 50)
print("EXPLORATORY DATA ANALYSIS - NUTRIMOOD")
print("=" * 50)

print("\n--- INFORMASI UMUM DATASET ---")
print("\n1. Dataset Makanan Indonesia:")
print(f"Jumlah baris: {indonesia_food_df.shape[0]}")
print(f"Jumlah kolom: {indonesia_food_df.shape[1]}")
print("\nKolom dalam dataset:")
print(indonesia_food_df.columns.tolist())
print("\nSampel data:")
print(indonesia_food_df.head())

print("\n2. Dataset Nutrisi:")
print(f"Jumlah baris: {nutrition_df.shape[0]}")
print(f"Jumlah kolom: {nutrition_df.shape[1]}")
print("\nKolom dalam dataset:")
print(nutrition_df.columns.tolist())
print("\nSampel data:")
print(nutrition_df.head())

print("\n3. Dataset Resep dan Bahan:")
print(f"Jumlah baris: {recipe_df.shape[0]}")
print(f"Jumlah kolom: {recipe_df.shape[1]}")
print("\nKolom dalam dataset:")
print(recipe_df.columns.tolist())
print("\nSampel data:")
print(recipe_df.head(2))  # Hanya tampilkan 2 baris karena datanya bisa jadi panjang

# Mengecek missing values
print("\n" + "=" * 50)
print("ANALISIS MISSING VALUES & STATISTIK DESKRIPTIF")
print("=" * 50)

print("\n--- MISSING VALUES ---")
print("\n1. Missing values dalam dataset makanan Indonesia:")
print(indonesia_food_df.isnull().sum())
print(f"Persentase data lengkap: {100 - (indonesia_food_df.isnull().sum().sum() / (indonesia_food_df.shape[0] * indonesia_food_df.shape[1]) * 100):.2f}%")

print("\n2. Missing values dalam dataset nutrisi:")
print(nutrition_df.isnull().sum())
print(f"Persentase data lengkap: {100 - (nutrition_df.isnull().sum().sum() / (nutrition_df.shape[0] * nutrition_df.shape[1]) * 100):.2f}%")

print("\n3. Missing values dalam dataset resep:")
# Khusus untuk dataset resep, kita hanya cek kolom utama
resep_main_cols = recipe_df.columns.tolist()
print(recipe_df[resep_main_cols].isnull().sum())
print(f"Persentase data lengkap: {100 - (recipe_df[resep_main_cols].isnull().sum().sum() / (recipe_df.shape[0] * len(resep_main_cols)) * 100):.2f}%")

# Statistik deskriptif
print("\n--- STATISTIK DESKRIPTIF ---")
print("\n1. Statistik dataset makanan Indonesia:")
print(indonesia_food_df.describe())

print("\n2. Statistik dataset nutrisi:")
print(nutrition_df.describe())

# Khusus untuk dataset resep, kita cek statistik dari panjang ingredients dan instructions
if 'Ingredients' in recipe_df.columns:
    recipe_df['ingredients_count'] = recipe_df['Ingredients'].apply(lambda x: len(eval(x)) if isinstance(x, str) else 0)
    print("\n3. Statistik jumlah bahan dalam resep:")
    print(recipe_df['ingredients_count'].describe())

if 'Instructions' in recipe_df.columns:
    recipe_df['instructions_length'] = recipe_df['Instructions'].apply(lambda x: len(str(x)) if isinstance(x, str) else 0)
    print("\nStatistik panjang instruksi dalam resep:")
    print(recipe_df['instructions_length'].describe())

# Analisis distribusi nutrisi
print("\n" + "=" * 50)
print("ANALISIS DISTRIBUSI NUTRISI - DATASET MAKANAN INDONESIA")
print("=" * 50)

# Membuat distribusi untuk nilai nutrisi
plt.figure(figsize=(14, 10))

plt.subplot(2, 2, 1)
sns.histplot(indonesia_food_df['calories'], bins=20, kde=True)
plt.title('Distribusi Kalori dalam Makanan Indonesia')
plt.xlabel('Kalori')
plt.ylabel('Frekuensi')
# Membatasi x-axis untuk visualisasi yang lebih baik (menghilangkan outlier ekstrem)
plt.xlim(0, 1000)

plt.subplot(2, 2, 2)
sns.histplot(indonesia_food_df['proteins'], bins=20, kde=True)
plt.title('Distribusi Protein dalam Makanan Indonesia')
plt.xlabel('Protein (g)')
plt.ylabel('Frekuensi')
plt.xlim(0, 50)

plt.subplot(2, 2, 3)
sns.histplot(indonesia_food_df['fat'], bins=20, kde=True)
plt.title('Distribusi Lemak dalam Makanan Indonesia')
plt.xlabel('Lemak (g)')
plt.ylabel('Frekuensi')
plt.xlim(0, 50)

plt.subplot(2, 2, 4)
sns.histplot(indonesia_food_df['carbohydrate'], bins=20, kde=True)
plt.title('Distribusi Karbohidrat dalam Makanan Indonesia')
plt.xlabel('Karbohidrat (g)')
plt.ylabel('Frekuensi')
plt.xlim(0, 100)

plt.tight_layout()
plt.savefig('distribusi_nutrisi.png')
plt.show()

# Boxplot untuk melihat outlier
plt.figure(figsize=(14, 10))

plt.subplot(2, 2, 1)
sns.boxplot(y=indonesia_food_df['calories'])
plt.title('Boxplot Kalori')
plt.ylabel('Kalori')

plt.subplot(2, 2, 2)
sns.boxplot(y=indonesia_food_df['proteins'])
plt.title('Boxplot Protein')
plt.ylabel('Protein (g)')

plt.subplot(2, 2, 3)
sns.boxplot(y=indonesia_food_df['fat'])
plt.title('Boxplot Lemak')
plt.ylabel('Lemak (g)')

plt.subplot(2, 2, 4)
sns.boxplot(y=indonesia_food_df['carbohydrate'])
plt.title('Boxplot Karbohidrat')
plt.ylabel('Karbohidrat (g)')

plt.tight_layout()
plt.savefig('boxplot_nutrisi.png')
plt.show()

# Analisis sebaran data makanan berdasarkan kandungan nutrisi
nutrisi_ranges = {
    'kalori': {'rendah': (0, 150), 'sedang': (150, 300), 'tinggi': (300, float('inf'))},
    'protein': {'rendah': (0, 5), 'sedang': (5, 15), 'tinggi': (15, float('inf'))},
    'lemak': {'rendah': (0, 5), 'sedang': (5, 15), 'tinggi': (15, float('inf'))},
    'karbohidrat': {'rendah': (0, 15), 'sedang': (15, 30), 'tinggi': (30, float('inf'))}
}

# Hitung jumlah makanan di setiap kategori
nutrisi_counts = {}
for nutrisi, ranges in nutrisi_ranges.items():
    counts = {}
    for kategori, (min_val, max_val) in ranges.items():
        if nutrisi == 'kalori':
            count = ((indonesia_food_df['calories'] >= min_val) &
                    (indonesia_food_df['calories'] < max_val)).sum()
        elif nutrisi == 'protein':
            count = ((indonesia_food_df['proteins'] >= min_val) &
                    (indonesia_food_df['proteins'] < max_val)).sum()
        elif nutrisi == 'lemak':
            count = ((indonesia_food_df['fat'] >= min_val) &
                    (indonesia_food_df['fat'] < max_val)).sum()
        elif nutrisi == 'karbohidrat':
            count = ((indonesia_food_df['carbohydrate'] >= min_val) &
                    (indonesia_food_df['carbohydrate'] < max_val)).sum()
        counts[kategori] = count
    nutrisi_counts[nutrisi] = counts

# Visualisasikan distribusi kategori nutrisi
plt.figure(figsize=(14, 8))

# Buat subplot untuk setiap nutrisi
nutrisi_names = list(nutrisi_counts.keys())
for i, nutrisi in enumerate(nutrisi_names, 1):
    plt.subplot(2, 2, i)
    categories = list(nutrisi_counts[nutrisi].keys())
    counts = list(nutrisi_counts[nutrisi].values())

    # Plot bar chart
    bars = plt.bar(categories, counts, color=['#66b3ff', '#99ff99', '#ff9999'])

    # Tambahkan label di atas setiap bar
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height + 5,
                f'{height}', ha='center', va='bottom')

    plt.title(f'Distribusi {nutrisi.capitalize()}')
    plt.ylabel('Jumlah Makanan')
    plt.ylim(0, max(counts) * 1.1)  # Tambahkan ruang untuk label

plt.tight_layout()
plt.savefig('distribusi_kategori_nutrisi.png')
plt.show()

# Top 10 makanan dengan kalori, protein, lemak, dan karbohidrat tertinggi
print("\n--- TOP 10 MAKANAN BERDASARKAN NUTRISI ---")

print("\nTop 10 Makanan dengan Kalori Tertinggi:")
top_calories = indonesia_food_df.sort_values('calories', ascending=False).head(10)
print(top_calories[['name', 'calories', 'proteins', 'fat', 'carbohydrate']])

print("\nTop 10 Makanan dengan Protein Tertinggi:")
top_protein = indonesia_food_df.sort_values('proteins', ascending=False).head(10)
print(top_protein[['name', 'proteins', 'calories', 'fat', 'carbohydrate']])

print("\nTop 10 Makanan dengan Lemak Tertinggi:")
top_fat = indonesia_food_df.sort_values('fat', ascending=False).head(10)
print(top_fat[['name', 'fat', 'calories', 'proteins', 'carbohydrate']])

print("\nTop 10 Makanan dengan Karbohidrat Tertinggi:")
top_carbs = indonesia_food_df.sort_values('carbohydrate', ascending=False).head(10)
print(top_carbs[['name', 'carbohydrate', 'calories', 'proteins', 'fat']])

# Analisis hubungan antar nutrisi
print("\n" + "=" * 50)
print("ANALISIS HUBUNGAN ANTAR NUTRISI")
print("=" * 50)

# Korelasi antar nutrisi pada dataset makanan Indonesia
nutrisi_cols = ['calories', 'proteins', 'fat', 'carbohydrate']
corr = indonesia_food_df[nutrisi_cols].corr()

plt.figure(figsize=(10, 8))
mask = np.triu(np.ones_like(corr, dtype=bool))  # Mask untuk segitiga atas
sns.heatmap(corr, annot=True, cmap='coolwarm', linewidths=0.5, mask=mask)
plt.title('Matriks Korelasi antar Nutrisi')
plt.tight_layout()
plt.savefig('korelasi_nutrisi.png')
plt.show()

print("\nMatriks Korelasi antar Nutrisi:")
print(corr)

# Scatter plot untuk melihat hubungan antar nutrisi
plt.figure(figsize=(14, 14))

# Calories vs Protein
plt.subplot(2, 2, 1)
sns.scatterplot(data=indonesia_food_df, x='proteins', y='calories', alpha=0.6)
plt.title('Hubungan Protein vs Kalori')
plt.xlabel('Protein (g)')
plt.ylabel('Kalori')
plt.xlim(0, 50)
plt.ylim(0, 800)

# Calories vs Fat
plt.subplot(2, 2, 2)
sns.scatterplot(data=indonesia_food_df, x='fat', y='calories', alpha=0.6)
plt.title('Hubungan Lemak vs Kalori')
plt.xlabel('Lemak (g)')
plt.ylabel('Kalori')
plt.xlim(0, 50)
plt.ylim(0, 800)

# Calories vs Carbohydrate
plt.subplot(2, 2, 3)
sns.scatterplot(data=indonesia_food_df, x='carbohydrate', y='calories', alpha=0.6)
plt.title('Hubungan Karbohidrat vs Kalori')
plt.xlabel('Karbohidrat (g)')
plt.ylabel('Kalori')
plt.xlim(0, 150)
plt.ylim(0, 800)

# Protein vs Carbohydrate
plt.subplot(2, 2, 4)
sns.scatterplot(data=indonesia_food_df, x='carbohydrate', y='proteins', alpha=0.6)
plt.title('Hubungan Karbohidrat vs Protein')
plt.xlabel('Karbohidrat (g)')
plt.ylabel('Protein (g)')
plt.xlim(0, 150)
plt.ylim(0, 50)

plt.tight_layout()
plt.savefig('scatter_nutrisi.png')
plt.show()

# Analisis distribusi makronutrien (pie chart)
def calculate_macronutrient_ratio(df):
    # Kalkulasi total kalori dari tiap makronutrien
    total_protein = df['proteins'].sum() * 4  # 4 kalori per gram protein
    total_fat = df['fat'].sum() * 9  # 9 kalori per gram lemak
    total_carbs = df['carbohydrate'].sum() * 4  # 4 kalori per gram karbohidrat

    # Total kalori dari semua makronutrien
    total = total_protein + total_fat + total_carbs

    # Persentase dari tiap makronutrien
    protein_pct = (total_protein / total) * 100 if total > 0 else 0
    fat_pct = (total_fat / total) * 100 if total > 0 else 0
    carbs_pct = (total_carbs / total) * 100 if total > 0 else 0

    print(f"\nDistribusi Makronutrien Berdasarkan Kalori:")
    print(f"Total Protein: {total_protein:.0f} kalori ({protein_pct:.1f}%)")
    print(f"Total Lemak: {total_fat:.0f} kalori ({fat_pct:.1f}%)")
    print(f"Total Karbohidrat: {total_carbs:.0f} kalori ({carbs_pct:.1f}%)")

    return protein_pct, fat_pct, carbs_pct

protein_pct, fat_pct, carbs_pct = calculate_macronutrient_ratio(indonesia_food_df)

plt.figure(figsize=(10, 8))
labels = ['Protein', 'Lemak', 'Karbohidrat']
sizes = [protein_pct, fat_pct, carbs_pct]
colors = ['#ff9999', '#66b3ff', '#99ff99']
explode = (0.1, 0, 0)  # Explode protein slice

plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
        shadow=True, startangle=90)
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle
plt.title('Distribusi Makronutrien dalam Dataset Makanan Indonesia\n(Berdasarkan kontribusi kalori)', fontsize=14)
plt.tight_layout()
plt.savefig('makronutrien_pie.png')
plt.show()

# Analisis dataset nutrisi
print("\n" + "=" * 50)
print("ANALISIS DATASET NUTRISI")
print("=" * 50)

# Visualisasi distribusi kalori di dataset nutrisi
plt.figure(figsize=(12, 8))
sns.histplot(nutrition_df['Calories'], bins=15, kde=True)
plt.title('Distribusi Kalori dalam Dataset Nutrisi')
plt.xlabel('Kalori')
plt.ylabel('Frekuensi')
plt.savefig('distribusi_kalori_nutrisi.png')
plt.show()

# Top 10 makanan dengan kalori tertinggi
top_calories_nutrition = nutrition_df.sort_values('Calories', ascending=False).head(15)

plt.figure(figsize=(12, 8))
sns.barplot(x='Calories', y='Food Name', data=top_calories_nutrition)
plt.title('15 Makanan dengan Kalori Tertinggi')
plt.xlabel('Kalori')
plt.tight_layout()
plt.savefig('top_kalori_nutrisi.png')
plt.show()

# Analisis nilai gizi (vitamins & minerals)
vit_min_cols = ['Vitamin A', 'Vitamin C', 'Vitamin B', 'Iron', 'Calcium']

# Melihat distribusi vitamin dan mineral
plt.figure(figsize=(18, 6))

for i, col in enumerate(vit_min_cols, 1):
    plt.subplot(1, 5, i)
    sns.histplot(nutrition_df[col], kde=True)
    plt.title(f'Distribusi {col}')
    plt.xlabel(col)
    plt.ylabel('Frekuensi')

plt.tight_layout()
plt.savefig('distribusi_vitamin_mineral.png')
plt.show()

# Top makanan dengan kandungan vitamin dan mineral tertinggi
print("\n--- TOP MAKANAN BERDASARKAN VITAMIN & MINERAL ---")

for nutrient in vit_min_cols:
    print(f"\nTop 5 Makanan dengan {nutrient} Tertinggi:")
    top_foods = nutrition_df.sort_values(nutrient, ascending=False).head(5)
    print(top_foods[['Food Name', nutrient, 'Calories', 'Protein']])

# Analisis perbandingan nilai gizi per 100g
print("\n--- NILAI GIZI PER 100g ---")

# Konversi ke per 100g untuk makanan yang memiliki berat sajian
nutrition_df['calories_per_100g'] = nutrition_df.apply(
    lambda row: row['Calories'] * 100 / row['Serving Size (grams)'] if row['Serving Size (grams)'] > 0 else None,
    axis=1
)

nutrition_df['protein_per_100g'] = nutrition_df.apply(
    lambda row: row['Protein'] * 100 / row['Serving Size (grams)'] if row['Serving Size (grams)'] > 0 else None,
    axis=1
)

# Visualisasi nilai kalori per 100g
top_density = nutrition_df.dropna(subset=['calories_per_100g']).sort_values('calories_per_100g', ascending=False).head(15)

plt.figure(figsize=(12, 8))
sns.barplot(x='calories_per_100g', y='Food Name', data=top_density)
plt.title('15 Makanan dengan Densitas Kalori Tertinggi (per 100g)')
plt.xlabel('Kalori per 100g')
plt.tight_layout()
plt.savefig('densitas_kalori.png')
plt.show()

# Visualisasi nilai protein per 100g
top_protein_density = nutrition_df.dropna(subset=['protein_per_100g']).sort_values('protein_per_100g', ascending=False).head(15)

plt.figure(figsize=(12, 8))
sns.barplot(x='protein_per_100g', y='Food Name', data=top_protein_density)
plt.title('15 Makanan dengan Densitas Protein Tertinggi (per 100g)')
plt.xlabel('Protein per 100g')
plt.tight_layout()
plt.savefig('densitas_protein.png')
plt.show()

# Analisis dataset resep
print("\n" + "=" * 50)
print("ANALISIS DATASET RESEP DAN BAHAN")
print("=" * 50)

# Jika dataset resep memiliki kolom yang dapat dianalisis
if 'Ingredients' in recipe_df.columns:
    # Hitung jumlah bahan untuk setiap resep
    if not 'ingredients_count' in recipe_df.columns:
        recipe_df['ingredients_count'] = recipe_df['Ingredients'].apply(lambda x: len(eval(x)) if isinstance(x, str) else 0)

    # Visualisasi distribusi jumlah bahan
    plt.figure(figsize=(12, 6))
    sns.histplot(recipe_df['ingredients_count'], bins=20, kde=True)
    plt.title('Distribusi Jumlah Bahan dalam Resep')
    plt.xlabel('Jumlah Bahan')
    plt.ylabel('Frekuensi')
    plt.savefig('distribusi_jumlah_bahan.png')
    plt.show()

    print(f"\nRata-rata jumlah bahan dalam resep: {recipe_df['ingredients_count'].mean():.2f}")
    print(f"Median jumlah bahan dalam resep: {recipe_df['ingredients_count'].median()}")
    print(f"Resep dengan bahan terbanyak memiliki {recipe_df['ingredients_count'].max()} bahan")
    print(f"Resep dengan bahan tersedikit memiliki {recipe_df['ingredients_count'].min()} bahan")

    # Ekstrak dan analisis bahan-bahan yang paling umum digunakan
    all_ingredients = []

    def extract_ingredients(ingredient_str):
        try:
            ingredients = eval(ingredient_str) if isinstance(ingredient_str, str) else []
            return [ing.lower().strip("'[]\" ") for ing in ingredients]
        except:
            return []

    for ingredients in recipe_df['Ingredients']:
        all_ingredients.extend(extract_ingredients(ingredients))

    # Hitung frekuensi bahan
    from collections import Counter
    ingredient_counts = Counter(all_ingredients)

    # Visualisasi 20 bahan paling umum
    top_ingredients = pd.DataFrame(ingredient_counts.most_common(20), columns=['Ingredient', 'Count'])

    plt.figure(figsize=(14, 10))
    sns.barplot(x='Count', y='Ingredient', data=top_ingredients)
    plt.title('20 Bahan Paling Umum dalam Resep')
    plt.xlabel('Jumlah Resep')
    plt.tight_layout()
    plt.savefig('top_bahan.png')
    plt.show()

    print("\nTop 20 bahan paling umum dalam resep:")
    for i, (ingredient, count) in enumerate(ingredient_counts.most_common(20), 1):
        print(f"{i}. {ingredient}: {count} resep")

# Kategori makanan berdasarkan mood
print("\n" + "=" * 50)
print("KATEGORI MAKANAN BERDASARKAN MOOD")
print("=" * 50)

# Definisikan kategori makanan berdasarkan profil nutrisi untuk mood yang berbeda
def categorize_food_by_mood(df):
    df_mood = df.copy()

    # Energizing: tinggi karbohidrat (>30g), protein sedang (5-15g)
    df_mood['energizing'] = ((df_mood['carbohydrate'] > 30) &
                           (df_mood['proteins'] >= 5) &
                           (df_mood['proteins'] <= 15))

    # Relaxing: rendah kalori (<150), rendah protein (<5g)
    df_mood['relaxing'] = ((df_mood['calories'] < 150) &
                          (df_mood['proteins'] < 5))

    # Focusing: tinggi protein (>15g), rendah karbohidrat (<10g)
    df_mood['focusing'] = ((df_mood['proteins'] > 15) &
                          (df_mood['carbohydrate'] < 10))

    return df_mood

# Kategorikan makanan Indonesia
indonesia_food_mood = categorize_food_by_mood(indonesia_food_df)

# Hitung jumlah makanan di setiap kategori
energizing_count = indonesia_food_mood['energizing'].sum()
relaxing_count = indonesia_food_mood['relaxing'].sum()
focusing_count = indonesia_food_mood['focusing'].sum()
multi_category = sum((indonesia_food_mood[['energizing', 'relaxing', 'focusing']].sum(axis=1) > 1).astype(int))
uncategorized = sum((indonesia_food_mood[['energizing', 'relaxing', 'focusing']].sum(axis=1) == 0).astype(int))

print(f"\nDistribusi Makanan Berdasarkan Kategori Mood:")
print(f"Energizing: {energizing_count} makanan ({energizing_count/len(indonesia_food_mood)*100:.1f}%)")
print(f"Relaxing: {relaxing_count} makanan ({relaxing_count/len(indonesia_food_mood)*100:.1f}%)")
print(f"Focusing: {focusing_count} makanan ({focusing_count/len(indonesia_food_mood)*100:.1f}%)")
print(f"Multi-Category: {multi_category} makanan ({multi_category/len(indonesia_food_mood)*100:.1f}%)")
print(f"Uncategorized: {uncategorized} makanan ({uncategorized/len(indonesia_food_mood)*100:.1f}%)")

# Visualisasi distribusi kategori mood
mood_categories = ['Energizing', 'Relaxing', 'Focusing', 'Multi-Category', 'Uncategorized']
mood_counts = [energizing_count, relaxing_count, focusing_count, multi_category, uncategorized]

plt.figure(figsize=(12, 8))
bars = plt.bar(mood_categories, mood_counts, color=['#ff9999', '#66b3ff', '#99ff99', '#ffcc99', '#c2c2f0'])

# Tambahkan label di atas bar
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height + 5,
            f'{height}', ha='center', va='bottom')

plt.title('Distribusi Makanan Berdasarkan Kategori Mood')
plt.ylabel('Jumlah Makanan')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.savefig('distribusi_mood.png')
plt.show()

# Top makanan untuk setiap kategori mood
print("\n--- TOP MAKANAN UNTUK SETIAP KATEGORI MOOD ---")

print("\nTop 10 Makanan untuk Meningkatkan Energi (Energizing):")
energizing_foods = indonesia_food_mood[indonesia_food_mood['energizing']].sort_values('calories', ascending=False).head(10)
print(energizing_foods[['name', 'calories', 'proteins', 'carbohydrate', 'fat']])

print("\nTop 10 Makanan untuk Relaksasi (Relaxing):")
relaxing_foods = indonesia_food_mood[indonesia_food_mood['relaxing']].sort_values('calories', ascending=False).head(10)
print(relaxing_foods[['name', 'calories', 'proteins', 'carbohydrate', 'fat']])

print("\nTop 10 Makanan untuk Fokus (Focusing):")
focusing_foods = indonesia_food_mood[indonesia_food_mood['focusing']].sort_values('proteins', ascending=False).head(10)
print(focusing_foods[['name', 'proteins', 'calories', 'carbohydrate', 'fat']])

# Visualisasi profil nutrisi untuk setiap kategori mood
def get_avg_nutrient_profile(df, category):
    category_foods = df[df[category]]

    # Hitung rata-rata dari setiap nutrisi
    avg_profile = {
        'calories': category_foods['calories'].mean(),
        'proteins': category_foods['proteins'].mean(),
        'fat': category_foods['fat'].mean(),
        'carbohydrate': category_foods['carbohydrate'].mean()
    }

    return avg_profile

# Dapatkan profil nutrisi rata-rata untuk setiap kategori
energizing_profile = get_avg_nutrient_profile(indonesia_food_mood, 'energizing')
relaxing_profile = get_avg_nutrient_profile(indonesia_food_mood, 'relaxing')
focusing_profile = get_avg_nutrient_profile(indonesia_food_mood, 'focusing')

print("\nProfil Nutrisi Rata-rata per Kategori Mood:")
print("\nEnergizing (Meningkatkan Energi):")
for nutrient, value in energizing_profile.items():
    print(f"- {nutrient}: {value:.2f}")

print("\nRelaxing (Relaksasi):")
for nutrient, value in relaxing_profile.items():
    print(f"- {nutrient}: {value:.2f}")

print("\nFocusing (Fokus):")
for nutrient, value in focusing_profile.items():
    print(f"- {nutrient}: {value:.2f}")

# Visualisasi profil nutrisi dengan bar chart
plt.figure(figsize=(14, 10))

# Siapkan data untuk diplot
categories = ['Energizing', 'Relaxing', 'Focusing']
calories = [energizing_profile['calories'], relaxing_profile['calories'], focusing_profile['calories']]
proteins = [energizing_profile['proteins'], relaxing_profile['proteins'], focusing_profile['proteins']]
fats = [energizing_profile['fat'], relaxing_profile['fat'], focusing_profile['fat']]
carbs = [energizing_profile['carbohydrate'], relaxing_profile['carbohydrate'], focusing_profile['carbohydrate']]

x = np.arange(len(categories))  # Label lokasi
width = 0.2  # Lebar bar

fig, ax = plt.subplots(figsize=(14, 8))
rects1 = ax.bar(x - width*1.5, calories, width, label='Kalori (x0.1)', color='#ff9999')
rects2 = ax.bar(x - width/2, proteins, width, label='Protein (g)', color='#66b3ff')
rects3 = ax.bar(x + width/2, fats, width, label='Lemak (g)', color='#99ff99')
rects4 = ax.bar(x + width*1.5, carbs, width, label='Karbohidrat (g)', color='#ffcc99')

# Tambahkan teks, label, dll.
ax.set_ylabel('Nilai')
ax.set_title('Profil Nutrisi Rata-rata berdasarkan Kategori Mood')
ax.set_xticks(x)
ax.set_xticklabels(categories)
ax.legend()

# Normalisasi nilai kalori untuk visualisasi yang lebih baik
for i, v in enumerate(calories):
    rects1[i].set_height(v / 10)  # Bagi kalori dengan 10 agar visualisasi lebih jelas

# Tambahkan label di atas bar
def autolabel(rects):
    for rect in rects:
        height = rect.get_height()
        ax.annotate(f'{height:.1f}',
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 poin vertikal offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=8)

autolabel(rects1)
autolabel(rects2)
autolabel(rects3)
autolabel(rects4)

fig.tight_layout()
plt.savefig('profil_nutrisi_mood.png')
plt.show()

# Integrasi dataset dan rekomendasi berdasarkan mood
print("\n" + "=" * 50)
print("INTEGRASI DATA DAN REKOMENDASI BERDASARKAN MOOD")
print("=" * 50)

# Mencoba menghubungkan dataset makanan Indonesia dengan dataset nutrisi tambahan
# Kita bisa mencocokkan berdasarkan nama makanan (meskipun akan ada tantangan dengan pencocokan nama)
# Ini adalah simulasi sederhana untuk menunjukkan konsep

# Fungsi sederhana untuk mencari kecocokan nama makanan
def find_food_match(name, df, column='Food Name'):
    # Mengubah nama menjadi lowercase untuk pencocokan yang lebih baik
    name_lower = name.lower()
    for idx, food_name in enumerate(df[column]):
        if isinstance(food_name, str) and name_lower in food_name.lower():
            return idx
    return None

# Tambahkan kolom vitamin dan mineral ke dataset makanan Indonesia jika ada kecocokan
indonesia_food_mood['vitamin_a'] = 0
indonesia_food_mood['vitamin_c'] = 0
indonesia_food_mood['calcium'] = 0
indonesia_food_mood['iron'] = 0

# Cari kecocokan dan tambahkan informasi nutrisi tambahan jika ditemukan
match_count = 0
for idx, row in indonesia_food_mood.iterrows():
    match_idx = find_food_match(row['name'], nutrition_df)
    if match_idx is not None:
        match_count += 1
        indonesia_food_mood.at[idx, 'vitamin_a'] = nutrition_df.iloc[match_idx]['Vitamin A']
        indonesia_food_mood.at[idx, 'vitamin_c'] = nutrition_df.iloc[match_idx]['Vitamin C']
        indonesia_food_mood.at[idx, 'calcium'] = nutrition_df.iloc[match_idx]['Calcium']
        indonesia_food_mood.at[idx, 'iron'] = nutrition_df.iloc[match_idx]['Iron']

print(f"\nDitemukan {match_count} kecocokan antara dataset makanan Indonesia dan dataset nutrisi.")

# Contoh penggunaan fitur untuk rekomendasi berdasarkan mood
print("\n--- CONTOH REKOMENDASI MAKANAN BERDASARKAN MOOD ---")

# Fungsi untuk mendapatkan rekomendasi makanan berdasarkan mood dan preferensi nutrisi
def get_mood_food_recommendations(df, mood, limit=5, nutrient_pref=None):
    if mood == 'energizing':
        filtered_df = df[df['energizing']]
    elif mood == 'relaxing':
        filtered_df = df[df['relaxing']]
    elif mood == 'focusing':
        filtered_df = df[df['focusing']]
    else:
        return "Mood tidak valid. Pilih 'energizing', 'relaxing', atau 'focusing'."

    # Jika ada preferensi nutrisi tambahan
    if nutrient_pref:
        if nutrient_pref == 'low_calorie':
            filtered_df = filtered_df.sort_values('calories')
        elif nutrient_pref == 'high_protein':
            filtered_df = filtered_df.sort_values('proteins', ascending=False)
        elif nutrient_pref == 'low_fat':
            filtered_df = filtered_df.sort_values('fat')
        elif nutrient_pref == 'high_carb':
            filtered_df = filtered_df.sort_values('carbohydrate', ascending=False)

    # Jika tidak ada preferensi, berikan rekomendasi berdasarkan nilai nutrisi utama untuk mood tersebut
    else:
        if mood == 'energizing':
            filtered_df = filtered_df.sort_values('carbohydrate', ascending=False)
        elif mood == 'relaxing':
            filtered_df = filtered_df.sort_values('calories')
        elif mood == 'focusing':
            filtered_df = filtered_df.sort_values('proteins', ascending=False)

    return filtered_df.head(limit)[['name', 'calories', 'proteins', 'fat', 'carbohydrate']]

# Contoh rekomendasi untuk berbagai mood dan preferensi
print("\nRekomendasi untuk mood 'Energizing' (Meningkatkan Energi):")
print(get_mood_food_recommendations(indonesia_food_mood, 'energizing'))

print("\nRekomendasi untuk mood 'Relaxing' (Relaksasi):")
print(get_mood_food_recommendations(indonesia_food_mood, 'relaxing'))

print("\nRekomendasi untuk mood 'Focusing' (Fokus):")
print(get_mood_food_recommendations(indonesia_food_mood, 'focusing'))

print("\nRekomendasi untuk mood 'Energizing' dengan preferensi rendah kalori:")
print(get_mood_food_recommendations(indonesia_food_mood, 'energizing', nutrient_pref='low_calorie'))

print("\nRekomendasi untuk mood 'Focusing' dengan preferensi tinggi protein:")
print(get_mood_food_recommendations(indonesia_food_mood, 'focusing', nutrient_pref='high_protein'))

# Analisis terkait kesehatan dan visualisasi akhir
print("\n" + "=" * 50)
print("ANALISIS KESEHATAN DAN VISUALISASI AKHIR")
print("=" * 50)

# Menetapkan kategori makanan berdasarkan keseimbangan nutrisi
def categorize_health_balance(row):
    # Persentase kalori dari protein, lemak, dan karbohidrat
    total_calories = (row['proteins'] * 4) + (row['fat'] * 9) + (row['carbohydrate'] * 4)

    if total_calories == 0:
        return 'undefined'

    protein_pct = (row['proteins'] * 4) / total_calories * 100
    fat_pct = (row['fat'] * 9) / total_calories * 100
    carb_pct = (row['carbohydrate'] * 4) / total_calories * 100

    # Kriteria keseimbangan makronutrien sederhana (ini dapat disesuaikan)
    if (protein_pct >= 10 and protein_pct <= 35) and (fat_pct >= 20 and fat_pct <= 35) and (carb_pct >= 45 and carb_pct <= 65):
        return 'balanced'
    elif protein_pct > 35:
        return 'high_protein'
    elif fat_pct > 35:
        return 'high_fat'
    elif carb_pct > 65:
        return 'high_carb'
    else:
        return 'other'

# Terapkan kategorisasi kesehatan
indonesia_food_mood['health_balance'] = indonesia_food_mood.apply(categorize_health_balance, axis=1)

# Hitung jumlah makanan di setiap kategori keseimbangan
health_balance_counts = indonesia_food_mood['health_balance'].value_counts()

print("\nDistribusi Makanan Berdasarkan Keseimbangan Nutrisi:")
for category, count in health_balance_counts.items():
    print(f"{category}: {count} makanan ({count/len(indonesia_food_mood)*100:.1f}%)")

# Visualisasi distribusi keseimbangan nutrisi
plt.figure(figsize=(12, 8))
sns.countplot(y='health_balance', data=indonesia_food_mood,
             order=health_balance_counts.index)
plt.title('Distribusi Makanan Berdasarkan Keseimbangan Nutrisi')
plt.xlabel('Jumlah Makanan')
plt.ylabel('Kategori Keseimbangan')
plt.tight_layout()
plt.savefig('distribusi_keseimbangan_nutrisi.png')
plt.show()

# Hubungan antara kategori mood dan keseimbangan nutrisi
mood_health_crosstab = pd.crosstab(
    [indonesia_food_mood['energizing'], indonesia_food_mood['relaxing'], indonesia_food_mood['focusing']],
    indonesia_food_mood['health_balance']
)

print("\nHubungan antara Kategori Mood dan Keseimbangan Nutrisi:")
print(mood_health_crosstab)

# Rekomendasi makanan seimbang untuk setiap mood
print("\n--- REKOMENDASI MAKANAN SEIMBANG UNTUK SETIAP MOOD ---")

def get_balanced_food_for_mood(df, mood, limit=5):
    if mood == 'energizing':
        filtered_df = df[(df['energizing']) & (df['health_balance'] == 'balanced')]
    elif mood == 'relaxing':
        filtered_df = df[(df['relaxing']) & (df['health_balance'] == 'balanced')]
    elif mood == 'focusing':
        filtered_df = df[(df['focusing']) & (df['health_balance'] == 'balanced')]
    else:
        return "Mood tidak valid. Pilih 'energizing', 'relaxing', atau 'focusing'."

    # Jika tidak ada makanan seimbang, coba ambil makanan dengan kategori health_balance lainnya
    if len(filtered_df) == 0:
        if mood == 'energizing':
            filtered_df = df[df['energizing']]
        elif mood == 'relaxing':
            filtered_df = df[df['relaxing']]
        elif mood == 'focusing':
            filtered_df = df[df['focusing']]

    # Urutkan berdasarkan kalori (sebagai contoh)
    filtered_df = filtered_df.sort_values('calories')

    return filtered_df.head(limit)[['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'health_balance']]

print("\nRekomendasi Makanan Seimbang untuk Mood 'Energizing':")
print(get_balanced_food_for_mood(indonesia_food_mood, 'energizing'))

print("\nRekomendasi Makanan Seimbang untuk Mood 'Relaxing':")
print(get_balanced_food_for_mood(indonesia_food_mood, 'relaxing'))

print("\nRekomendasi Makanan Seimbang untuk Mood 'Focusing':")
print(get_balanced_food_for_mood(indonesia_food_mood, 'focusing'))

# Visualisasi akhir: Radar chart untuk profil nutrisi berdasarkan kategori mood dan kesehatan
def plot_radar_chart(categories, values, title):
    # Set up the radar chart
    angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False).tolist()
    values += values[:1]  # Close the loop
    angles += angles[:1]  # Close the loop

    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))
    ax.plot(angles, values, 'o-', linewidth=2)
    ax.fill(angles, values, alpha=0.25)
    ax.set_thetagrids(np.degrees(angles[:-1]), categories)
    ax.set_title(title, size=15, pad=20)
    ax.grid(True)

    return fig, ax

# Normalisasi data untuk visualisasi radar yang lebih baik
def normalize_values(values):
    max_val = max(values)
    if max_val > 0:
        return [val / max_val for val in values]
    return values

# Profil nutrisi untuk kombinasi mood dan kesehatan
categories = ['Kalori', 'Protein', 'Lemak', 'Karbohidrat']

# Energizing & Balanced
energizing_balanced = indonesia_food_mood[(indonesia_food_mood['energizing']) &
                                        (indonesia_food_mood['health_balance'] == 'balanced')]

if len(energizing_balanced) > 0:
    values = [
        energizing_balanced['calories'].mean(),
        energizing_balanced['proteins'].mean(),
        energizing_balanced['fat'].mean(),
        energizing_balanced['carbohydrate'].mean()
    ]

    values = normalize_values(values)
    plt.figure(figsize=(10, 10))
    plot_radar_chart(categories, values, 'Profil Nutrisi: Energizing & Balanced')
    plt.tight_layout()
    plt.savefig('radar_energizing_balanced.png')
    plt.show()

# Focusing & High Protein
focusing_high_protein = indonesia_food_mood[(indonesia_food_mood['focusing']) &
                                          (indonesia_food_mood['health_balance'] == 'high_protein')]

if len(focusing_high_protein) > 0:
    values = [
        focusing_high_protein['calories'].mean(),
        focusing_high_protein['proteins'].mean(),
        focusing_high_protein['fat'].mean(),
        focusing_high_protein['carbohydrate'].mean()
    ]

    values = normalize_values(values)
    plt.figure(figsize=(10, 10))
    plot_radar_chart(categories, values, 'Profil Nutrisi: Focusing & High Protein')
    plt.tight_layout()
    plt.savefig('radar_focusing_high_protein.png')
    plt.show()

# Relaxing & Low Calorie
# Untuk ini, kita tidak melihat health_balance, tapi lansung filter berdasarkan kalori rendah
relaxing_low_cal = indonesia_food_mood[(indonesia_food_mood['relaxing']) &
                                     (indonesia_food_mood['calories'] < 100)]

if len(relaxing_low_cal) > 0:
    values = [
        relaxing_low_cal['calories'].mean(),
        relaxing_low_cal['proteins'].mean(),
        relaxing_low_cal['fat'].mean(),
        relaxing_low_cal['carbohydrate'].mean()
    ]

    values = normalize_values(values)
    plt.figure(figsize=(10, 10))
    plot_radar_chart(categories, values, 'Profil Nutrisi: Relaxing & Low Calorie')
    plt.tight_layout()
    plt.savefig('radar_relaxing_low_cal.png')
    plt.show()

# Kesimpulan dan insight untuk model rekomendasi
print("\n" + "=" * 50)
print("KESIMPULAN DAN INSIGHT UNTUK MODEL REKOMENDASI")
print("=" * 50)

# Simpan data yang telah dikategorikan untuk digunakan dalam model
indonesia_food_mood.to_csv('indonesia_food_mood_categorized.csv', index=False)

print("\nData yang telah dikategorikan disimpan sebagai 'indonesia_food_mood_categorized.csv'")

# Ringkasan insight dari EDA
print("""
INSIGHT DARI EXPLORATORY DATA ANALYSIS:

1. Karakteristik Dataset:
   - Dataset Makanan Indonesia memiliki 1,346 jenis makanan dengan informasi kalori, protein, lemak, dan karbohidrat.
   - Dataset Nutrisi memiliki 53 jenis makanan dengan informasi vitamin dan mineral tambahan.
   - Dataset Resep memiliki 13,501 resep yang dapat digunakan untuk rekomendasi cara memasak.

2. Distribusi Nutrisi:
   - Kalori: Sebagian besar makanan Indonesia memiliki kandungan kalori antara 0-400 kalori.
   - Protein: Mayoritas makanan memiliki kandungan protein di bawah 20g.
   - Lemak: Distribusi cenderung condong ke kanan dengan sebagian besar makanan mengandung lemak di bawah 15g.
   - Karbohidrat: Distribusi juga condong ke kanan dengan mayoritas makanan mengandung karbohidrat di bawah 50g.

3. Kategori Makanan Berdasarkan Mood:
   - Energizing (Meningkatkan Energi): Makanan tinggi karbohidrat (>30g) dengan protein sedang (5-15g).
   - Relaxing (Relaksasi): Makanan rendah kalori (<150) dan rendah protein (<5g).
   - Focusing (Fokus): Makanan tinggi protein (>15g) dan rendah karbohidrat (<10g).

4. Profil Nutrisi per Kategori Mood:
   - Energizing: Rata-rata kalori lebih tinggi, karbohidrat tinggi, protein sedang.
   - Relaxing: Kalori rendah, karbohidrat dan protein rendah.
   - Focusing: Kalori sedang, protein tinggi, karbohidrat rendah.

5. Keseimbangan Nutrisi:
   - Mayoritas makanan dalam dataset tidak memiliki keseimbangan nutrisi yang ideal.
   - Makanan seimbang (balanced) cenderung lebih sedikit dibandingkan dengan kategori lainnya.

6. Rekomendasi untuk Pengembangan Model:
   a. Fitur yang dapat digunakan:
      - Kategori mood (energizing, relaxing, focusing)
      - Profil nutrisi (kalori, protein, lemak, karbohidrat)
      - Keseimbangan nutrisi
      - Vitamin dan mineral (jika data tersedia)
      - Preferensi pengguna (dapat ditambahkan melalui input pengguna)

   b. Pendekatan Model:
      - Content-based filtering: Merekomendasikan makanan berdasarkan profil nutrisi
      - Collaborative filtering: Merekomendasikan makanan berdasarkan preferensi pengguna lain
      - Hybrid approach: Kombinasi dari keduanya

   c. Skenario Rekomendasi:
      - Rekomendasi berdasarkan mood saat ini
      - Rekomendasi berdasarkan tujuan kesehatan (misalnya diet rendah kalori, tinggi protein)
      - Rekomendasi berdasarkan waktu hari (sarapan, makan siang, makan malam)
      - Rekomendasi variasi makanan untuk menghindari kejenuhan

   d. Tantangan:
      - Integrasi data dari berbagai sumber
      - Pencocokan nama makanan antar dataset
      - Validasi efek makanan terhadap mood perlu penelitian lebih lanjut

7. Langkah Selanjutnya:
   - Pengembangan model Machine Learning untuk rekomendasi
   - Validasi model dengan melibatkan ahli gizi dan psikolog
   - Pengujian dengan pengguna nyata
   - Implementasi dalam aplikasi dengan antarmuka pengguna yang intuitif
""")

print("\nEDA untuk proyek NutriMood telah selesai!")

"""# **Penyatuan Dataset**"""

# Import library yang diperlukan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files
import re
import warnings
warnings.filterwarnings('ignore')

# Set style plot
plt.style.use('ggplot')
sns.set(style="whitegrid")
plt.rcParams['figure.figsize'] = (12, 8)

# Membaca dataset
indonesia_food_df = pd.read_csv('indonesiaFoodandDrink.csv')
nutrition_df = pd.read_csv('nutritionDataset.csv')
recipe_df = pd.read_csv('Food Ingredients and Recipe Dataset with Image Name Mapping.csv')

print("\n== INFORMASI DATASET AWAL ==")
print(f"Dataset Makanan Indonesia: {indonesia_food_df.shape[0]} baris, {indonesia_food_df.shape[1]} kolom")
print(f"Dataset Nutrisi: {nutrition_df.shape[0]} baris, {nutrition_df.shape[1]} kolom")
print(f"Dataset Resep: {recipe_df.shape[0]} baris, {recipe_df.shape[1]} kolom")

# Step 1: Definisikan kategori makanan berdasarkan mood
def categorize_food_by_mood(df):
    df_mood = df.copy()

    # Energizing: tinggi karbohidrat (>30g), protein sedang (5-15g)
    df_mood['is_energizing'] = ((df_mood['carbohydrate'] > 30) &
                             (df_mood['proteins'] >= 5) &
                             (df_mood['proteins'] <= 15)).astype(int)

    # Relaxing: rendah kalori (<150), rendah protein (<5g)
    df_mood['is_relaxing'] = ((df_mood['calories'] < 150) &
                            (df_mood['proteins'] < 5)).astype(int)

    # Focusing: tinggi protein (>15g), rendah karbohidrat (<10g)
    df_mood['is_focusing'] = ((df_mood['proteins'] > 15) &
                            (df_mood['carbohydrate'] < 10)).astype(int)

    # Tambahkan kolom primary_mood untuk klasifikasi utama
    conditions = [
        (df_mood['is_energizing'] == 1) & (df_mood['is_relaxing'] == 0) & (df_mood['is_focusing'] == 0),
        (df_mood['is_energizing'] == 0) & (df_mood['is_relaxing'] == 1) & (df_mood['is_focusing'] == 0),
        (df_mood['is_energizing'] == 0) & (df_mood['is_relaxing'] == 0) & (df_mood['is_focusing'] == 1),
        (df_mood['is_energizing'] + df_mood['is_relaxing'] + df_mood['is_focusing'] > 1)
    ]
    choices = ['energizing', 'relaxing', 'focusing', 'multi_category']
    df_mood['primary_mood'] = np.select(conditions, choices, default='uncategorized')

    return df_mood

# Step 2: Menambahkan kategori kesehatan
def add_health_categories(df):
    df_health = df.copy()

    # Kategori berdasarkan kalori
    df_health['calorie_category'] = pd.cut(
        df_health['calories'],
        bins=[0, 100, 200, 400, float('inf')],
        labels=['very_low', 'low', 'medium', 'high']
    )

    # Kategori berdasarkan protein
    df_health['protein_category'] = pd.cut(
        df_health['proteins'],
        bins=[0, 5, 15, 30, float('inf')],
        labels=['very_low', 'low', 'medium', 'high']
    )

    # Kategori berdasarkan lemak
    df_health['fat_category'] = pd.cut(
        df_health['fat'],
        bins=[0, 5, 15, 30, float('inf')],
        labels=['very_low', 'low', 'medium', 'high']
    )

    # Kategori berdasarkan karbohidrat
    df_health['carb_category'] = pd.cut(
        df_health['carbohydrate'],
        bins=[0, 15, 30, 50, float('inf')],
        labels=['very_low', 'low', 'medium', 'high']
    )

    # Hitung keseimbangan nutrisi
    def calculate_nutrient_balance(row):
        total_calories = (row['proteins'] * 4) + (row['fat'] * 9) + (row['carbohydrate'] * 4)

        if total_calories == 0:
            return 'undefined'

        protein_pct = (row['proteins'] * 4) / total_calories * 100
        fat_pct = (row['fat'] * 9) / total_calories * 100
        carb_pct = (row['carbohydrate'] * 4) / total_calories * 100

        # Kriteria keseimbangan nutrisi (dapat disesuaikan)
        if (protein_pct >= 10 and protein_pct <= 35) and (fat_pct >= 20 and fat_pct <= 35) and (carb_pct >= 45 and carb_pct <= 65):
            return 'balanced'
        elif protein_pct > 35:
            return 'high_protein'
        elif fat_pct > 35:
            return 'high_fat'
        elif carb_pct > 65:
            return 'high_carb'
        else:
            return 'other'

    df_health['nutrient_balance'] = df_health.apply(calculate_nutrient_balance, axis=1)

    return df_health

# Step 3: Persiapkan dataset makanan Indonesia dengan kategori
indonesia_food_enriched = indonesia_food_df.copy()
indonesia_food_enriched = categorize_food_by_mood(indonesia_food_enriched)
indonesia_food_enriched = add_health_categories(indonesia_food_enriched)

# Step 4: Bersihkan dan standarisasi nama makanan untuk pencocokan
def clean_food_name(name):
    if not isinstance(name, str):
        return str(name)

    # Hapus karakter non-alfanumerik dan ubah ke lowercase
    name = re.sub(r'[^a-zA-Z0-9\s]', '', name.lower())
    # Standardisasi spasi
    name = re.sub(r'\s+', ' ', name).strip()

    # Koreksi nama-nama umum (dapat ditambahkan lagi)
    corrections = {
        'ayam': 'chicken',
        'nasi': 'rice',
        'ikan': 'fish',
        'udang': 'shrimp',
        'daging': 'meat',
        'sup': 'soup',
        'kari': 'curry',
        'goreng': 'fried'
    }

    for indo, eng in corrections.items():
        name = name.replace(indo, eng)

    return name

# Tambahkan kolom nama yang dibersihkan untuk pencocokan
indonesia_food_enriched['clean_name'] = indonesia_food_enriched['name'].apply(clean_food_name)
nutrition_df['clean_name'] = nutrition_df['Food Name'].apply(clean_food_name)

if 'Title' in recipe_df.columns:
    recipe_df['clean_name'] = recipe_df['Title'].apply(clean_food_name)

# Step 5: Coba cocokkan dataset nutrisi dengan makanan Indonesia
def find_best_match(name, target_df, threshold=0.6):
    name_tokens = set(name.split())
    best_match_idx = None
    best_match_score = 0

    for idx, target_name in enumerate(target_df['clean_name']):
        target_tokens = set(target_name.split())

        # Hitung Jaccard similarity
        if len(name_tokens) == 0 or len(target_tokens) == 0:
            continue

        intersection = len(name_tokens.intersection(target_tokens))
        union = len(name_tokens.union(target_tokens))

        similarity = intersection / union if union > 0 else 0

        if similarity > best_match_score:
            best_match_score = similarity
            best_match_idx = idx

    # Jika similaritas di atas threshold, anggap cocok
    if best_match_score >= threshold and best_match_idx is not None:
        return best_match_idx, best_match_score

    return None, 0

# Inisialisasi kolom untuk data nutrisi tambahan
nutrition_columns = ['Vitamin A', 'Vitamin C', 'Vitamin B', 'Iron', 'Calcium']
for col in nutrition_columns:
    indonesia_food_enriched[col.lower().replace(' ', '_')] = 0

# Mencoba mencocokkan dan menambahkan data nutrisi
match_count = 0
match_details = []

for idx, row in indonesia_food_enriched.iterrows():
    best_match_idx, similarity = find_best_match(row['clean_name'], nutrition_df)

    if best_match_idx is not None:
        match_count += 1
        match_food = nutrition_df.iloc[best_match_idx]

        # Tambahkan informasi nutrisi
        for col in nutrition_columns:
            col_name = col.lower().replace(' ', '_')
            indonesia_food_enriched.at[idx, col_name] = match_food[col]

        # Simpan detail pencocokan untuk validasi
        match_details.append({
            'indonesia_food': row['name'],
            'nutrition_food': match_food['Food Name'],
            'similarity': similarity
        })

print(f"\nDitemukan {match_count} kecocokan antara dataset makanan Indonesia dan dataset nutrisi.")

# Step 6: Coba cocokkan dengan dataset resep
# Inisialisasi kolom untuk data resep
indonesia_food_enriched['has_recipe'] = 0
indonesia_food_enriched['recipe_title'] = ''
indonesia_food_enriched['ingredients'] = ''
indonesia_food_enriched['instructions'] = ''

# Mencoba mencocokkan dan menambahkan data resep
recipe_match_count = 0

if 'Title' in recipe_df.columns and 'Ingredients' in recipe_df.columns and 'Instructions' in recipe_df.columns:
    for idx, row in indonesia_food_enriched.iterrows():
        best_match_idx, similarity = find_best_match(row['clean_name'], recipe_df, threshold=0.5)  # Threshold lebih rendah untuk resep

        if best_match_idx is not None:
            recipe_match_count += 1
            match_recipe = recipe_df.iloc[best_match_idx]

            # Tambahkan informasi resep
            indonesia_food_enriched.at[idx, 'has_recipe'] = 1
            indonesia_food_enriched.at[idx, 'recipe_title'] = match_recipe['Title']
            indonesia_food_enriched.at[idx, 'ingredients'] = match_recipe['Ingredients']
            indonesia_food_enriched.at[idx, 'instructions'] = match_recipe['Instructions']

print(f"Ditemukan {recipe_match_count} kecocokan antara dataset makanan Indonesia dan dataset resep.")

# Step 7: Bersihkan dan normalisasi kolom yang berisi list dalam bentuk string
def clean_list_string(list_str):
    if not isinstance(list_str, str):
        return []

    try:
        # Coba evaluasi string sebagai list Python
        return eval(list_str)
    except:
        # Jika gagal, coba metode parsing sederhana
        list_str = list_str.strip("[]'\"")
        items = re.findall(r"'([^']*)'", list_str)
        if items:
            return items
        else:
            # Jika tetap gagal, pisahkan dengan koma
            return [item.strip() for item in list_str.split(',') if item.strip()]

# Bersihkan kolom ingredients jika ada
if 'ingredients' in indonesia_food_enriched.columns:
    indonesia_food_enriched['ingredients_list'] = indonesia_food_enriched['ingredients'].apply(clean_list_string)

    # Tambahkan jumlah bahan sebagai fitur
    indonesia_food_enriched['ingredient_count'] = indonesia_food_enriched['ingredients_list'].apply(len)

# Step 8: Tambahkan fitur untuk model rekomendasi
# Encode mood kategori sebagai one-hot
mood_dummies = pd.get_dummies(indonesia_food_enriched['primary_mood'], prefix='mood')
indonesia_food_enriched = pd.concat([indonesia_food_enriched, mood_dummies], axis=1)

# Encode kategori kesehatan sebagai fitur numerik
health_mapping = {'very_low': 1, 'low': 2, 'medium': 3, 'high': 4}

for col in ['calorie_category', 'protein_category', 'fat_category', 'carb_category']:
    indonesia_food_enriched[col + '_num'] = indonesia_food_enriched[col].map(health_mapping)

# Encode nutrient balance
balance_mapping = {'balanced': 5, 'high_protein': 4, 'high_fat': 3, 'high_carb': 2, 'other': 1, 'undefined': 0}
indonesia_food_enriched['nutrient_balance_num'] = indonesia_food_enriched['nutrient_balance'].map(balance_mapping)

# Step 9: Normalisasi fitur numerik untuk model
from sklearn.preprocessing import MinMaxScaler

# Kolom yang akan dinormalisasi
numeric_cols = [
    'calories', 'proteins', 'fat', 'carbohydrate',
    'vitamin_a', 'vitamin_c', 'vitamin_b', 'iron', 'calcium',
    'calorie_category_num', 'protein_category_num', 'fat_category_num', 'carb_category_num',
    'nutrient_balance_num'
]

# Pastikan semua kolom ada
numeric_cols = [col for col in numeric_cols if col in indonesia_food_enriched.columns]

# Normalisasi fitur numerik
scaler = MinMaxScaler()
indonesia_food_enriched[numeric_cols] = scaler.fit_transform(indonesia_food_enriched[numeric_cols])

# Step 10: Siapkan dataset akhir untuk model
# Pilih kolom yang akan digunakan untuk model
model_features = [
    'id', 'name', 'calories', 'proteins', 'fat', 'carbohydrate',
    'is_energizing', 'is_relaxing', 'is_focusing', 'primary_mood',
    'calorie_category', 'protein_category', 'fat_category', 'carb_category',
    'nutrient_balance'
]

# Tambahkan kolom vitamin dan mineral jika ada
for col in ['vitamin_a', 'vitamin_c', 'vitamin_b', 'iron', 'calcium']:
    if col in indonesia_food_enriched.columns:
        model_features.append(col)

# Tambahkan kolom resep jika ada
if 'has_recipe' in indonesia_food_enriched.columns:
    model_features.append('has_recipe')

# Tambahkan kolom fitur numerik yang telah dinormalisasi
for col in numeric_cols:
    if col in indonesia_food_enriched.columns and col not in model_features:
        model_features.append(col)

# Tambahkan kolom mood one-hot
for col in mood_dummies.columns:
    model_features.append(col)

# Buat dataset final untuk model
final_dataset = indonesia_food_enriched[model_features].copy()

# Tampilkan statistik dataset akhir
print("\n== INFORMASI DATASET AKHIR ==")
print(f"Dataset Final: {final_dataset.shape[0]} baris, {final_dataset.shape[1]} kolom")
print("\nContoh data (5 baris pertama):")
print(final_dataset.head())

# Hitung distribusi mood
print("\nDistribusi Mood:")
print(final_dataset['primary_mood'].value_counts())

# Simpan dataset akhir ke CSV
final_dataset.to_csv('nutrimood_combined_dataset.csv', index=False)
print("\nDataset gabungan telah disimpan sebagai 'nutrimood_combined_dataset.csv'")

# BONUS: Buat model rekomendasi sederhana berbasis content-based filtering
from sklearn.metrics.pairwise import cosine_similarity

# Membaca dataset
nutrimood_df = pd.read_csv('nutrimood_combined_dataset.csv')

# Menampilkan informasi tentang dataset
print("\n== INFORMASI DATASET AWAL ==")
print(f"Dataset Makanan Indonesia: {nutrimood_df.shape[0]} baris, {nutrimood_df.shape[1]} kolom")

# Menampilkan 5 baris pertama dari dataset
print("\nContoh Data (5 baris pertama):")
display(nutrimood_df)

# Menampilkan informasi umum tentang kolom-kolom di dataset
nutrimood_df.info()

"""# Data Preprocessing

## Memeriksa Nilai yang Hilang (Missing Values)
"""

# Menampilkan jumlah nilai yang hilang per kolom
print("\nJumlah nilai yang hilang per kolom:")
missing_values = nutrimood_df.isnull().sum()
print(missing_values[missing_values > 0])

# Mendefinisikan daftar kolom yang ingin diperiksa missing values-nya
kolom_kategori = [
    'calorie_category',
    'protein_category',
    'fat_category',
    'carb_category',
    'calorie_category_num',
    'protein_category_num',
    'fat_category_num',
    'carb_category_num'
]

# Menampilkan baris-baris yang memiliki missing value di kolom-kolom tersebut
baris_missing = nutrimood_df[nutrimood_df[kolom_kategori].isnull().any(axis=1)]

# Menampilkan hasil
print("Jumlah baris dengan missing values:", len(baris_missing))
print(baris_missing)

"""## Menyalin Dataset Asli untuk Backup"""

nutrimood_original = nutrimood_df.copy()

"""## Melakukan Preprocessing Awal"""

print("\n=== PREPROCESSING AWAL ===")

# Menghapus kolom id karena tidak digunakan dalam pemrosesan
nutrimood_df = nutrimood_df.drop(columns=['id'])

# Memisahkan kolom kategorikal dan numerik untuk penanganan yang tepat
categorical_columns = ['primary_mood', 'calorie_category', 'protein_category',
                       'fat_category', 'carb_category', 'nutrient_balance']
numerical_columns = nutrimood_df.select_dtypes(include=['float64', 'int64']).columns.tolist()
boolean_columns = nutrimood_df.select_dtypes(include=['bool']).columns.tolist()

print(f"Kolom kategorikal: {categorical_columns}")
print(f"Jumlah kolom numerik: {len(numerical_columns)}")
print(f"Kolom boolean: {boolean_columns}")

"""## Memeriksa Hubungan antara Nilai Numerik dan Kategori"""

# Memeriksa apakah calorie_category berhubungan dengan calorie_category_num
print("\nSampel hubungan kategori dan nilai numerik:")
sample_df = nutrimood_df[['calorie_category', 'calorie_category_num']].dropna().drop_duplicates().sort_values('calorie_category_num')
print(sample_df)

"""## Menganalisis Distribusi Nilai Kategorikal"""

kategori_kolom = [
    'calorie_category', 'protein_category', 'fat_category', 'carb_category',
    'calorie_category_num', 'protein_category_num', 'fat_category_num', 'carb_category_num'
]

for col in kategori_kolom:
    if col in nutrimood_df.columns:
        print(f'\nDistribusi nilai pada kolom: {col}')
        print(nutrimood_df[col].value_counts(dropna=False, normalize=True))

"""## Mendefinisikan Fungsi untuk Imputasi Prediktif Berbasis Model"""

def predictive_imputation(data, target_column, categorical=False):
    print(f"Melakukan imputasi prediktif untuk kolom: {target_column}")
    # Menyalin data untuk mencegah perubahan pada data asli
    df_copy = nutrimood_df.copy()

    # Mengidentifikasi baris dengan nilai yang hilang pada kolom target
    missing_mask = df_copy[target_column].isnull()

    # Jika tidak ada nilai yang hilang, mengembalikan data asli
    if not missing_mask.any():
        print(f" - Tidak ada nilai yang hilang pada kolom {target_column}")
        return df_copy

    print(f" - Jumlah nilai yang hilang: {missing_mask.sum()}")

    # Memilih fitur yang akan digunakan untuk prediksi
    exclude_cols = [target_column]

    # Jika target adalah kolom kategori numerik, juga keluarkan versi kategori stringnya dan sebaliknya
    if target_column.endswith('_num') and target_column[:-4] in df_copy.columns:
        exclude_cols.append(target_column[:-4])
    elif target_column + '_num' in df_copy.columns:
        exclude_cols.append(target_column + '_num')

    # Memilih fitur untuk prediksi (numerik dan boolean)
    potential_features = [col for col in numerical_columns + boolean_columns if col not in exclude_cols]

    # Menghapus kolom dengan nilai yang hilang dari fitur potensial untuk menghindari masalah selama pelatihan model
    features = []
    for col in potential_features:
        # Menghitung persentase nilai yang hilang
        missing_percentage = df_copy[col].isnull().mean()
        if missing_percentage == 0:  # Kolom tidak memiliki nilai yang hilang sama sekali
            features.append(col)

    print(f" - Jumlah fitur yang digunakan: {len(features)}")
    print(f" - Fitur yang digunakan: {features[:5]}..." if len(features) > 5 else f" - Fitur yang digunakan: {features}")

    # Memisahkan data training (baris yang tidak memiliki nilai yang hilang pada kolom target)
    X_train = df_copy.loc[~missing_mask, features]
    y_train = df_copy.loc[~missing_mask, target_column]

    # Data untuk prediksi (baris yang memiliki nilai yang hilang pada kolom target)
    X_pred = df_copy.loc[missing_mask, features]

    # Jika kolom target adalah kategorikal
    if categorical:
        # Mengkonversi kolom kategorikal ke numerik untuk pelatihan model
        label_encoder = LabelEncoder()
        y_train_encoded = label_encoder.fit_transform(y_train)

        # Melatih model Random Forest Classifier
        model = RandomForestClassifier(random_state=42, n_estimators=100, class_weight='balanced')
        model.fit(X_train, y_train_encoded)

        # Memprediksi nilai yang hilang
        y_pred_encoded = model.predict(X_pred)
        y_pred = label_encoder.inverse_transform(y_pred_encoded)
    else:
        # Melatih model Random Forest Regressor
        model = RandomForestRegressor(random_state=42, n_estimators=100)
        model.fit(X_train, y_train)

        # Memprediksi nilai yang hilang
        y_pred = model.predict(X_pred)

    # Mengisi nilai yang hilang dengan prediksi
    df_copy.loc[missing_mask, target_column] = y_pred

    # Menampilkan beberapa nilai hasil prediksi
    num_to_show = min(5, len(y_pred))
    print(f" - Contoh {num_to_show} nilai hasil prediksi:")
    for i in range(num_to_show):
        print(f" {y_pred[i]}")

    return df_copy

"""## Mengimplementasikan Imputasi untuk Data yang Hilang"""

# Melakukan imputasi untuk kolom kategori
print("Imputasi untuk kolom kategorikal:")
categorical_columns_missing = ['calorie_category', 'protein_category', 'fat_category', 'carb_category']
for col in categorical_columns_missing:
    if col in nutrimood_df.columns and nutrimood_df[col].isnull().sum() > 0:
        nutrimood_df = predictive_imputation(nutrimood_df, col, categorical=True)

# Melakukan imputasi untuk kolom numerik kategori
print("\nImputasi untuk kolom numerik kategori:")
numeric_category_cols = ['calorie_category_num', 'protein_category_num', 'fat_category_num', 'carb_category_num']
for col in numeric_category_cols:
    if col in nutrimood_df.columns and nutrimood_df[col].isnull().sum() > 0:
        nutrimood_df = predictive_imputation(nutrimood_df, col, categorical=False)

# Memverifikasi Hasil Imputasi
print("\n=== VERIFIKASI HASIL IMPUTASI ===")
print("Jumlah nilai yang hilang setelah imputasi:")
missing_after = nutrimood_df.isnull().sum()
print(missing_after[missing_after > 0] if missing_after.sum() > 0 else "Tidak ada nilai yang hilang")

# Menyimpan hasil imputasi ke file CSV
nutrimood_df.to_csv('nutrimood_full_cat.csv', index=False)

"""## Memilih Fitur untuk Model Rekomendasi"""

features = nutrimood_df.drop(columns=[
    'is_energizing',
    'is_relaxing',
    'is_focusing',
    'nutrient_balance',
    'calorie_category_num',
    'protein_category_num',
    'fat_category_num',
    'carb_category_num',
    'nutrient_balance_num',
    'mood_energizing',
    'mood_focusing',
    'mood_relaxing',
    'mood_uncategorized',
    'has_recipe',
    'vitamin_a',
    'vitamin_c',
    'vitamin_b',
    'iron',
    'calcium'
])

#  Mengatur tampilan untuk melihat semua kolom
pd.set_option('display.max_columns', None)
features.head()

"""## Melakukan Standarisasi Fitur Numerik


"""

# Menentukan kolom numerik yang perlu distandarisasi
numerical_cols = ['calories', 'proteins', 'fat', 'carbohydrate']

# Membuat objek scaler dan melakukan standarisasi
scaler = StandardScaler()
features[numerical_cols] = scaler.fit_transform(features[numerical_cols])

# Memeriksa hasil akhir preprocessing
print(features.head())

# Menyimpan hasil preprocessing ke file CSV
features.to_csv('nutrimood_preprocessed_cat.csv', index=False)

"""## Melakukan Encoding Kategori"""

# Menggunakan Label Encoding karena kategori memiliki tingkatan
le = LabelEncoder()
for col in ['calorie_category', 'protein_category', 'fat_category', 'carb_category']:
    features[col] = le.fit_transform(features[col])

# Buat LabelEncoder dan transformasi kolom
encoder = LabelEncoder()
features['primary_mood'] = encoder.fit_transform(features['primary_mood'])

print(features)
print("Mapping:")
for mood, code in zip(encoder.classes_, encoder.transform(encoder.classes_)):
    print(f"{mood}  {code}")

# Menyimpan hasil preprocessing ke file CSV
features.to_csv('nutrimood_preprocessed_num.csv', index=False)

"""# MODELLING"""

import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models, regularizers
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics.pairwise import cosine_similarity
import joblib
import pickle
import os

"""
## MODEL 1: Klasifikasi Mood

"""

class MoodClassifier:
    def __init__(self):
        self.model = None
        self.encoder = None
        self.feature_scaler = None

    def build_model(self, input_shape, num_classes):
        """Membangun arsitektur model mood classifier menggunakan TensorFlow"""

        # Model Sequential dengan Dense Layers
        model = models.Sequential([
            layers.Dense(128, activation='relu', kernel_regularizer=regularizers.l2(0.001), input_shape=input_shape),
            layers.BatchNormalization(),
            layers.Dropout(0.3),

            layers.Dense(64, activation='relu', kernel_regularizer=regularizers.l2(0.001)),
            layers.BatchNormalization(),
            layers.Dropout(0.2),

            layers.Dense(32, activation='relu'),
            layers.BatchNormalization(),

            layers.Dense(num_classes, activation='softmax')
        ])

        # Kompilasi model
        model.compile(
            optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
            loss='categorical_crossentropy',
            metrics=['accuracy']
        )

        self.model = model
        return model

    def preprocess_features(self, X):
        """Preprocess fitur input untuk klasifikasi mood"""
        # Normalisasi data input agar berada dalam rentang yang sama
        if self.feature_scaler is None:
            self.feature_scaler = StandardScaler()
            X_scaled = self.feature_scaler.fit_transform(X)
        else:
            X_scaled = self.feature_scaler.transform(X)
        return X_scaled

    def preprocess_labels(self, y):
        """Preprocess label dengan one-hot encoding"""
        if self.encoder is None:
            self.encoder = OneHotEncoder(sparse_output=False)
            y_encoded = self.encoder.fit_transform(y.reshape(-1, 1))
        else:
            y_encoded = self.encoder.transform(y.reshape(-1, 1))
        return y_encoded

    def fit(self, X, y, epochs=50, batch_size=32, validation_split=0.2):
        """Melatih model klasifikasi mood"""
        # Preprocess data
        X_scaled = self.preprocess_features(X)
        y_encoded = self.preprocess_labels(y)

        # Bagi data menjadi data latih dan validasi
        X_train, X_val, y_train, y_val = train_test_split(
            X_scaled, y_encoded, test_size=validation_split, random_state=42
        )

        # Bangun model jika belum ada
        if self.model is None:
            self.build_model((X_scaled.shape[1],), y_encoded.shape[1])

        # Latih model
        history = self.model.fit(
            X_train, y_train,
            epochs=epochs,
            batch_size=batch_size,
            validation_data=(X_val, y_val),
            callbacks=[
                tf.keras.callbacks.EarlyStopping(
                    monitor='val_loss', patience=5, restore_best_weights=True
                )
            ]
        )

        return history

    def predict(self, X):
        """Prediksi kelas mood dari fitur input"""
        # Preprocess data
        X_scaled = self.preprocess_features(X)

        # Prediksi probabilitas untuk setiap kelas
        y_pred_proba = self.model.predict(X_scaled)

        # Ambil kelas dengan probabilitas tertinggi
        y_pred = np.argmax(y_pred_proba, axis=1)

        # Kembalikan ke label asli
        mood_labels = self.encoder.inverse_transform(np.eye(y_pred_proba.shape[1])[y_pred])

        return mood_labels.flatten()

    def predict_proba(self, X):
        """Prediksi probabilitas untuk setiap kelas mood"""
        # Preprocess data
        X_scaled = self.preprocess_features(X)

        # Prediksi probabilitas untuk setiap kelas
        y_pred_proba = self.model.predict(X_scaled)

        return y_pred_proba

    def save(self, model_path='mood_classifier_model.keras', scaler_path='mood_feature_scaler.pkl', encoder_path='mood_encoder.pkl'):
        """Menyimpan model dan transformer"""
        # Simpan model TensorFlow dengan ekstensi .keras
        self.model.save(model_path)

        # Simpan scaler dan encoder
        joblib.dump(self.feature_scaler, scaler_path)
        joblib.dump(self.encoder, encoder_path)

    def load(self, model_path='mood_classifier_model.keras', scaler_path='mood_feature_scaler.pkl', encoder_path='mood_encoder.pkl'):
        """Memuat model dan transformer dari file"""
        # Muat model TensorFlow dengan ekstensi .keras
        self.model = tf.keras.models.load_model(model_path)

        # Muat scaler dan encoder
        self.feature_scaler = joblib.load(scaler_path)
        self.encoder = joblib.load(encoder_path)

"""## MODEL 2: Sistem Rekomendasi"""

class FoodRecommender:
    def __init__(self):
        self.food_df = None
        self.mood_mapping = {
            'energizing': 0,
            'relaxing': 1,
            'focusing': 2,
            'multi_category': 3,
            'uncategorized': 4
        }
        self.health_mapping = {
            'diabetes': {'calorie_category': 'low', 'carb_category': 'low'},
            'hipertensi': {'calorie_category': 'low', 'fat_category': 'low'},
            'kolesterol': {'fat_category': 'low'},
            'obesitas': {'calorie_category': 'low', 'fat_category': 'low'},
            'alergi_gluten': {'nutrient_balance': 'balanced'},
            'vegetarian': {'primary_mood': ['relaxing', 'energizing']}
        }
        self.feature_weights = {
            'calories': 1.0,
            'proteins': 1.0,
            'fat': 1.0,
            'carbohydrate': 1.0,
            'calorie_category': 2.0,
            'protein_category': 1.5,
            'fat_category': 1.5,
            'carb_category': 1.5,
            'nutrient_balance': 2.0,
            'primary_mood': 3.0,
            'mood_energizing': 2.0,
            'mood_relaxing': 2.0,
            'mood_focusing': 2.0,
            'vitamin_a': 0.5,
            'vitamin_c': 0.5,
            'vitamin_b': 0.5,
            'iron': 0.5,
            'calcium': 0.5
        }

    def load_data(self, food_data_path):
        """Memuat dataset makanan dan mempersiapkannya untuk rekomendasi"""
        self.food_df = pd.read_csv(food_data_path)

        # Pastikan kolom penting ada
        required_cols = ['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'primary_mood']
        for col in required_cols:
            if col not in self.food_df.columns:
                raise ValueError(f"Kolom {col} tidak ditemukan dalam dataset makanan")

        print(f"Data makanan dimuat dengan sukses: {self.food_df.shape[0]} item")
        return self.food_df

    def encode_mood(self, mood):
        """Encode mood string into a numeric value"""
        mood_mapping = {
            'energizing': 0,
            'relaxing': 1,
            'focusing': 2,
            'multi_category': 3,
            'uncategorized': 4  # Make sure 'uncategorized' is mapped to a number
        }
        return mood_mapping.get(mood, 4)  # Default to 'uncategorized' if not found

    def get_food_similarity(self, user_profile):
        """Menghitung kesamaan antara profil pengguna dan makanan dalam dataset"""
        if self.food_df is None:
            raise ValueError("Dataset makanan belum dimuat. Panggil load_data() terlebih dahulu.")

        # Encode all non-numeric features in the user_profile
        for key, value in user_profile.items():
            if isinstance(value, str):  # Check if the value is a string (like 'uncategorized')
                user_profile[key] = self.encode_mood(value)  # Convert it to numeric

        # Ekstrak fitur numerik dan kategori untuk perhitungan kesamaan
        feature_cols = [col for col in self.food_df.columns
                        if col in self.feature_weights and col != 'name']

        # Pastikan hanya fitur numerik yang digunakan
        feature_cols = [col for col in feature_cols if pd.api.types.is_numeric_dtype(self.food_df[col])]

        # Buat DataFrame untuk profil pengguna dengan fitur yang sama
        user_df = pd.DataFrame([user_profile])

        # Map user_profile features to actual dataset columns
        feature_mapping = {
            'calorie_category': 'calorie_category_num',
            'protein_category': 'protein_category_num',
            'fat_category': 'fat_category_num',
            'carb_category': 'carb_category_num',
            'mood_uncategorized': 'mood_uncategorized'
        }

        # Update user_profile with the correct feature names from food_df
        updated_user_profile = {}
        for key, value in user_profile.items():
            if key in feature_mapping:
                updated_user_profile[feature_mapping[key]] = value
            else:
                updated_user_profile[key] = value

        print(f"Profil pengguna yang telah diperbarui: {updated_user_profile}")

        # Pastikan profil pengguna memiliki fitur yang ada dalam dataset makanan
        feature_cols = [col for col in self.food_df.columns if col in updated_user_profile]

        if len(feature_cols) == 0:
            raise ValueError("Profil pengguna tidak memiliki fitur yang valid.")

        updated_user_profile = {col: updated_user_profile[col] for col in feature_cols}

        # Hitung kesamaan langsung di sini, bukan dengan pemanggilan rekursif
        food_features = self.food_df[feature_cols].values
        user_features = np.array([list(updated_user_profile.values())])

        # Hitung kesamaan kosinus
        similarities = cosine_similarity(user_features, food_features)[0]

        # Tambahkan skor kesamaan ke dataframe
        self.food_df['similarity_score'] = similarities

        # Urutkan berdasarkan skor kesamaan dan kembalikan rekomendasi
        recommendations = self.food_df.sort_values('similarity_score', ascending=False).head(5)

        return recommendations[['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'primary_mood', 'similarity_score']]




    def recommend_for_mood(self, mood, top_n=5, health_conditions=None):
        """Merekomendasikan makanan berdasarkan mood dan kondisi kesehatan"""
        if self.food_df is None:
            raise ValueError("Dataset makanan belum dimuat. Panggil load_data() terlebih dahulu.")

        # Buat profil pengguna berdasarkan mood
        user_profile = {
            'primary_mood': mood,
            f'mood_{mood}': 1.0
        }

        # Mapping kondisi kesehatan ke fitur yang ada dalam dataset
        if health_conditions:
            for condition in health_conditions:
                if condition in self.health_mapping:
                    for feature, value in self.health_mapping[condition].items():
                        if isinstance(value, list):
                            # Jika nilai adalah list, pilih nilai pertama saja untuk profil
                            user_profile[feature] = value[0]
                        else:
                            user_profile[feature] = value

        # Map user_profile features to the actual dataset columns
        feature_mapping = {
            'calorie_category': 'calorie_category_num',
            'protein_category': 'protein_category_num',
            'fat_category': 'fat_category_num',
            'carb_category': 'carb_category_num',
            'mood_uncategorized': 'mood_uncategorized'
        }

        # Update user_profile with the correct feature names from food_df
        updated_user_profile = {}
        for key, value in user_profile.items():
            if key in feature_mapping:
                updated_user_profile[feature_mapping[key]] = value
            else:
                updated_user_profile[key] = value

        # Verify the updated user_profile
        print(f"Profil pengguna yang telah diperbarui: {updated_user_profile}")

        # Pastikan profil pengguna memiliki fitur yang ada dalam dataset makanan
        feature_cols = [col for col in self.food_df.columns if col in updated_user_profile]

        print(f"Fitur yang cocok antara dataset dan profil pengguna: {feature_cols}")

        updated_user_profile = {col: updated_user_profile[col] for col in feature_cols}

        # Cek apakah profil pengguna memiliki fitur yang valid
        if len(updated_user_profile) == 0:
            raise ValueError("Profil pengguna tidak memiliki fitur yang valid.")

        # Hitung kesamaan
        self.get_food_similarity(updated_user_profile)

        # Filter makanan yang sesuai dengan mood
        if mood in ['energizing', 'relaxing', 'focusing']:
            mood_filtered = self.food_df[self.food_df['primary_mood'] == mood]
        else:
            # Jika mood tidak spesifik, gunakan semua makanan
            mood_filtered = self.food_df

        # Jika kondisi kesehatan diberikan, terapkan filter tambahan
        if health_conditions:
            for condition in health_conditions:
                if condition in self.health_mapping:
                    for feature, value in self.health_mapping[condition].items():
                        if isinstance(value, list):
                            # Jika nilai adalah list, filter berdasarkan keberadaan dalam list
                            mood_filtered = mood_filtered[mood_filtered[feature].isin(value)]
                        else:
                            # Jika nilai adalah string atau nilai tunggal, filter yang cocok
                            mood_filtered = mood_filtered[mood_filtered[feature] == value]

        # Jika tidak ada makanan yang cocok setelah filter, kembali ke dataset awal dan urutkan berdasarkan kesamaan
        if len(mood_filtered) == 0:
            print("Tidak ada makanan yang cocok dengan filter yang diberikan. Menggunakan semua makanan.")
            mood_filtered = self.food_df

        # Urutkan berdasarkan skor kesamaan
        recommendations = mood_filtered.sort_values('similarity_score', ascending=False).head(top_n)

        # Kembalikan nama dan detail makanan
        result = recommendations[['name', 'calories', 'proteins', 'fat', 'carbohydrate',
                                'primary_mood', 'similarity_score']]

        return result



    def save(self, model_path='food_recommender.pkl'):
        """Menyimpan model rekomendasi"""
        # Simpan model Food Recommender
        with open(model_path, 'wb') as f:
            pickle.dump(self, f)

    @classmethod
    def load(cls, model_path='food_recommender.pkl'):
        """Memuat model rekomendasi dari file"""
        # Muat model Food Recommender
        with open(model_path, 'rb') as f:
            model = pickle.load(f)
        return model

"""## MODEL TRAINING

"""

def train_mood_classifier(data_path):
    """Melatih model klasifikasi mood"""
    # Muat data
    data = pd.read_csv(data_path)

    # Siapkan fitur dan label
    # Asumsikan fitur adalah data kesehatan (misal: calorie_category, protein_category, dll)
    features = data[['calorie_category', 'protein_category', 'fat_category', 'carb_category']]

    # Konversi fitur kategori menjadi numerik
    for col in features.columns:
        mapping = {'very_low': 0, 'low': 1, 'medium': 2, 'high': 3}
        features[col] = features[col].map(mapping)

    # Target adalah primary_mood
    labels = data['primary_mood']

    # Buat dan latih model
    classifier = MoodClassifier()
    history = classifier.fit(features.values, labels.values, epochs=30)

    # Simpan model
    classifier.save('mood_classifier_model.keras')  # Save model with .keras extension

    return classifier

def prepare_food_recommender(data_path):
    """Mempersiapkan model rekomendasi makanan"""
    recommender = FoodRecommender()
    recommender.load_data(data_path)
    recommender.save('food_recommender.pkl')  # Save recommender model

    return recommender

"""## INFERENCE"""

def predict_mood_from_health_data(health_data, model_path='mood_classifier_model.keras'):
    """Memprediksi mood berdasarkan data kesehatan"""
    # Muat model
    classifier = MoodClassifier()
    classifier.load(model_path)

    # Ubah input menjadi format yang sesuai
    input_features = np.array([[health_data.get('calories_category', 1),  # Default ke 'low'
                                health_data.get('protein_category', 1),
                                health_data.get('fat_category', 1),
                                health_data.get('carb_category', 1)]])

    # Prediksi mood
    predicted_mood = classifier.predict(input_features)[0]

    return predicted_mood

def get_food_recommendations(mood, health_conditions=None, top_n=5, model_path='food_recommender.pkl'):
    """Mendapatkan rekomendasi makanan berdasarkan mood dan kondisi kesehatan"""
    # Muat model
    recommender = FoodRecommender.load(model_path)

    # Dapatkan rekomendasi
    recommendations = recommender.recommend_for_mood(mood, top_n, health_conditions)

    return recommendations

"""## CONTOH PENGGUNAAN"""

def main():
    """Contoh penggunaan model"""
    # Path ke file data
    data_path = 'nutrimood_preprocessed.csv'

    # 1. Latih model klasifikasi mood
    print("Melatih model klasifikasi mood...")
    mood_classifier = train_mood_classifier(data_path)

    # 2. Persiapkan model rekomendasi makanan
    print("Mempersiapkan model rekomendasi makanan...")
    food_recommender = prepare_food_recommender(data_path)

    # 3. Contoh inference
    print("\nCONTOH INFERENCE:")

    # Contoh data kesehatan pengguna
    user_health_data = {
        'calories_category': 1,  # 'low'
        'protein_category': 2,   # 'medium'
        'fat_category': 1,       # 'low'
        'carb_category': 2       # 'medium'
    }

    # Prediksi mood berdasarkan data kesehatan
    predicted_mood = predict_mood_from_health_data(user_health_data)
    print(f"Mood yang diprediksi: {predicted_mood}")

    # Tentukan kondisi kesehatan
    health_conditions = ['diabetes']

    # Dapatkan rekomendasi makanan
    recommendations = get_food_recommendations(predicted_mood, health_conditions)

    print("\nRekomendasi makanan berdasarkan mood dan kondisi kesehatan:")
    print(recommendations)

    # 4. Contoh input manual
    print("\nCONTOH INPUT MANUAL:")

    # Input mood secara manual
    manual_mood = 'energizing'
    print(f"Mood yang dipilih: {manual_mood}")

    # Dapatkan rekomendasi makanan
    manual_recommendations = get_food_recommendations(manual_mood, health_conditions)

    print("\nRekomendasi makanan berdasarkan mood dan kondisi kesehatan:")
    print(manual_recommendations)


if __name__ == "__main__":
    main()

"""## Inference sederhana"""

import pandas as pd
import numpy as np
import tensorflow as tf
import pickle
import joblib
import argparse

class NutriMoodInference:
    """
    Kelas untuk melakukan inferensi pada model NutriMood
    """
    def __init__(self, model_path='mood_classifier_model',
                 scaler_path='mood_feature_scaler.pkl',
                 encoder_path='mood_encoder.pkl',
                 recommender_path='food_recommender.pkl'):
        # Load mood classifier model
        self.model = tf.keras.models.load_model(model_path)
        self.feature_scaler = joblib.load(scaler_path)
        self.encoder = joblib.load(encoder_path)

        # Load food recommender
        with open(recommender_path, 'rb') as f:
            self.recommender = pickle.load(f)

        # Mapping kategori ke nilai numerik
        self.category_mapping = {
            'very_low': 0, 'low': 1, 'medium': 2, 'high': 3
        }

        # Konversi nilai numerik ke kategori
        self.reverse_mapping = {v: k for k, v in self.category_mapping.items()}

    def predict_mood(self, health_data):
        """
        Memprediksi mood berdasarkan data kesehatan

        Parameters:
        -----------
        health_data : dict
            Dictionary berisi data kesehatan (calorie_category, protein_category, etc.)

        Returns:
        --------
        str
            Mood yang diprediksi
        """
        # Konversi string kategori ke nilai numerik jika perlu
        numeric_health_data = {}
        for key, value in health_data.items():
            if isinstance(value, str) and value in self.category_mapping:
                numeric_health_data[key] = self.category_mapping[value]
            else:
                numeric_health_data[key] = value

        # Siapkan feature vector
        features = np.array([
            numeric_health_data.get('calorie_category', 1),
            numeric_health_data.get('protein_category', 1),
            numeric_health_data.get('fat_category', 1),
            numeric_health_data.get('carb_category', 1)
        ]).reshape(1, -1)

        # Preprocess data
        features_scaled = self.feature_scaler.transform(features)

        # Prediksi mood
        proba = self.model.predict(features_scaled)
        pred_class = np.argmax(proba, axis=1)[0]

        # Decode kelas menjadi mood label
        mood_labels = self.encoder.inverse_transform(np.eye(proba.shape[1])[pred_class].reshape(1, -1))[0][0]

        # Kembalikan mood dan probabilitas
        return mood_labels, proba[0]

    def get_recommendations(self, mood, health_conditions=None, top_n=5):
        """
        Mendapatkan rekomendasi makanan berdasarkan mood dan kondisi kesehatan

        Parameters:
        -----------
        mood : str
            Mood yang ingin digunakan untuk rekomendasi
        health_conditions : list
            List kondisi kesehatan yang perlu dipertimbangkan
        top_n : int
            Jumlah rekomendasi yang diinginkan

        Returns:
        --------
        DataFrame
            Rekomendasi makanan
        """
        return self.recommender.recommend_for_mood(mood, top_n, health_conditions)

    def process_user_input(self, calorie_level='medium', protein_level='medium',
                          fat_level='low', carb_level='medium',
                          health_conditions=None, manual_mood=None, top_n=5):
        """
        Memproses input pengguna dan mengembalikan rekomendasi makanan

        Parameters:
        -----------
        calorie_level : str
            Tingkat kalori (very_low, low, medium, high)
        protein_level : str
            Tingkat protein (very_low, low, medium, high)
        fat_level : str
            Tingkat lemak (very_low, low, medium, high)
        carb_level : str
            Tingkat karbohidrat (very_low, low, medium, high)
        health_conditions : list
            List kondisi kesehatan
        manual_mood : str
            Mood yang diinput manual, jika ada
        top_n : int
            Jumlah rekomendasi

        Returns:
        --------
        dict
            Dictionary berisi mood dan rekomendasi makanan
        """
        # Siapkan health data
        health_data = {
            'calorie_category': calorie_level,
            'protein_category': protein_level,
            'fat_category': fat_level,
            'carb_category': carb_level
        }

        # Jika mood tidak diberikan secara manual, prediksi dari data kesehatan
        if manual_mood is None:
            mood, mood_probabilities = self.predict_mood(health_data)
            print(f"Mood yang diprediksi: {mood}")

            # Tampilkan probabilitas untuk setiap mood
            mood_names = ['energizing', 'relaxing', 'focusing', 'uncategorized', 'multi_category']
            print("Probabilitas untuk setiap mood:")
            for i, m in enumerate(mood_names):
                if i < len(mood_probabilities):
                    print(f"- {m}: {mood_probabilities[i]:.4f}")
        else:
            mood = manual_mood
            print(f"Menggunakan mood yang dipilih manual: {mood}")

        # Dapatkan rekomendasi makanan
        recommendations = self.get_recommendations(mood, health_conditions, top_n)

        return {
            'mood': mood,
            'recommendations': recommendations
        }


def main():
    """Fungsi utama untuk menjalankan inferensi secara command line"""
    parser = argparse.ArgumentParser(description='NutriMood Inference Tool')

    # Parameter input
    parser.add_argument('--calorie', choices=['very_low', 'low', 'medium', 'high'],
                       default='medium', help='Tingkat kalori')
    parser.add_argument('--protein', choices=['very_low', 'low', 'medium', 'high'],
                       default='medium', help='Tingkat protein')
    parser.add_argument('--fat', choices=['very_low', 'low', 'medium', 'high'],
                       default='low', help='Tingkat lemak')
    parser.add_argument('--carb', choices=['very_low', 'low', 'medium', 'high'],
                       default='medium', help='Tingkat karbohidrat')
    parser.add_argument('--health', nargs='+',
                       choices=['diabetes', 'hipertensi', 'kolesterol', 'vegetarian', 'alergi_gluten'],
                       help='Kondisi kesehatan (dapat memilih lebih dari satu)')
    parser.add_argument('--mood', choices=['energizing', 'relaxing', 'focusing', 'uncategorized'],
                       help='Mood manual (opsional)')
    parser.add_argument('--top', type=int, default=5, help='Jumlah rekomendasi')

    # Parse argumen
    args = parser.parse_args()

    try:
        # Inisialisasi inference
        inference = NutriMoodInference()

        # Proses input dan dapatkan rekomendasi
        result = inference.process_user_input(
            calorie_level=args.calorie,
            protein_level=args.protein,
            fat_level=args.fat,
            carb_level=args.carb,
            health_conditions=args.health,
            manual_mood=args.mood,
            top_n=args.top
        )

        # Tampilkan hasil
        print("\n===== REKOMENDASI MAKANAN =====")
        print(f"Mood: {result['mood']}")
        print("\nMakanan yang direkomendasikan:")
        print(result['recommendations'][['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'similarity_score']])

    except Exception as e:
        print(f"Error: {e}")
        print("Pastikan model sudah dilatih dan file model tersedia.")


# Contoh penggunaan sebagai script
if __name__ == "__main__":
    main()

# Contoh penggunaan sebagai library
def example_usage():
    """Contoh penggunaan NutriMoodInference sebagai library"""
    # Inisialisasi inference
    inference = NutriMoodInference()

    # Contoh 1: Prediksi mood dari data kesehatan dan dapatkan rekomendasi
    health_data = {
        'calorie_category': 'low',
        'protein_category': 'medium',
        'fat_category': 'low',
        'carb_category': 'medium'
    }

    # Prediksi mood
    mood, probabilities = inference.predict_mood(health_data)
    print(f"Mood yang diprediksi: {mood}")

    # Dapatkan rekomendasi
    health_conditions = ['diabetes']
    recommendations = inference.get_recommendations(mood, health_conditions, top_n=3)
    print("\nRekomendasi makanan:")
    print(recommendations[['name', 'calories', 'proteins', 'fat', 'carbohydrate']])

    # Contoh 2: Gunakan process_user_input untuk memproses input dan mendapatkan rekomendasi
    result = inference.process_user_input(
        calorie_level='medium',
        protein_level='high',
        fat_level='low',
        carb_level='low',
        health_conditions=['hipertensi'],
        manual_mood='focusing',  # Gunakan manual mood
        top_n=5
    )

    print("\nHasil dengan mood manual:")
    print(f"Mood: {result['mood']}")
    print(result['recommendations'][['name', 'calories', 'proteins', 'fat', 'carbohydrate']])

    # Contoh 3: Gunakan process_user_input tanpa manual mood (akan diprediksi)
    result = inference.process_user_input(
        calorie_level='high',
        protein_level='high',
        fat_level='medium',
        carb_level='low',
        health_conditions=['vegetarian'],
        top_n=5
    )

    print("\nHasil dengan mood yang diprediksi:")
    print(f"Mood: {result['mood']}")
    print(result['recommendations'][['name', 'calories', 'proteins', 'fat', 'carbohydrate']])

"""## Evaluasi"""

import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder

def load_and_preprocess_data(data_path):
    """
    Memuat dan memproses dataset untuk pelatihan
    """
    # Memuat dataset
    data = pd.read_csv(data_path)

    # Melihat informasi dataset
    print(f"Dataset shape: {data.shape}")
    print(f"Columns: {data.columns.tolist()}")

    # Menangani missing values jika ada
    missing_vals = data.isnull().sum()
    if missing_vals.sum() > 0:
        print("Missing values detected:")
        print(missing_vals[missing_vals > 0])

        # Mengisi missing values sederhana (bisa disesuaikan dengan kebutuhan)
        # Untuk kolom numerik, gunakan mean
        numeric_cols = data.select_dtypes(include=['float64', 'int64']).columns
        for col in numeric_cols:
            if data[col].isnull().sum() > 0:
                data[col].fillna(data[col].mean(), inplace=True)

        # Untuk kolom kategorikal, gunakan mode
        cat_cols = data.select_dtypes(include=['object']).columns
        for col in cat_cols:
            if data[col].isnull().sum() > 0:
                data[col].fillna(data[col].mode()[0], inplace=True)

    # Mempersiapkan data untuk model mood classifier
    # Asumsikan fitur adalah kategori nutrisi dan target adalah primary_mood

    # Fitur: kategori nutrisi
    X = data[['calorie_category', 'protein_category', 'fat_category', 'carb_category']]

    # Label: primary_mood
    y = data['primary_mood']

    # Encoding fitur kategorikal
    # Konversi fitur kategori menjadi numerik
    for col in X.columns:
        mapping = {'very_low': 0, 'low': 1, 'medium': 2, 'high': 3}
        X[col] = X[col].map(mapping)

    # Encoding label
    le = LabelEncoder()
    y_encoded = le.fit_transform(y)

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(
        X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded
    )

    # Normalisasi fitur
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    # One-hot encoding untuk label
    ohe = OneHotEncoder(sparse=False)
    y_train_onehot = ohe.fit_transform(y_train.reshape(-1, 1))
    y_test_onehot = ohe.transform(y_test.reshape(-1, 1))

    # Menyimpan encoder dan scaler
    encoders = {
        'label_encoder': le,
        'onehot_encoder': ohe,
        'feature_scaler': scaler
    }

    # Informasi label
    label_mapping = {i: label for i, label in enumerate(le.classes_)}
    print("\nLabel mapping:")
    for i, label in label_mapping.items():
        print(f"{i}: {label}")

    # Mengembalikan data dan encoder
    return {
        'X_train': X_train_scaled,
        'X_test': X_test_scaled,
        'y_train': y_train_onehot,
        'y_test': y_test_onehot,
        'y_train_raw': y_train,
        'y_test_raw': y_test,
        'encoders': encoders,
        'label_mapping': label_mapping
    }

def build_mood_classifier(input_shape, num_classes):
    """
    Membangun arsitektur model mood classifier
    """
    # Model Sequential dengan Dense Layers
    model = tf.keras.models.Sequential([
        tf.keras.layers.Dense(128, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.001),
                             input_shape=input_shape),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.3),

        tf.keras.layers.Dense(64, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.001)),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.2),

        tf.keras.layers.Dense(32, activation='relu'),
        tf.keras.layers.BatchNormalization(),

        tf.keras.layers.Dense(num_classes, activation='softmax')
    ])

    # Kompilasi model
    model.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
        loss='categorical_crossentropy',
        metrics=['accuracy']
    )

    return model

def train_and_evaluate_model(data, save_model=True):
    """
    Melatih dan mengevaluasi model mood classifier
    """
    # Ekstrak data
    X_train = data['X_train']
    X_test = data['X_test']
    y_train = data['y_train']
    y_test = data['y_test']
    y_test_raw = data['y_test_raw']
    encoders = data['encoders']
    label_mapping = data['label_mapping']

    # Bangun model
    input_shape = (X_train.shape[1],)
    num_classes = y_train.shape[1]
    model = build_mood_classifier(input_shape, num_classes)

    # Tampilkan ringkasan model
    model.summary()

    # Latih model
    history = model.fit(
        X_train, y_train,
        epochs=50,
        batch_size=32,
        validation_split=0.2,
        callbacks=[
            tf.keras.callbacks.EarlyStopping(
                monitor='val_loss', patience=5, restore_best_weights=True
            )
        ],
        verbose=1
    )

    # Plot history training
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Train')
    plt.plot(history.history['val_accuracy'], label='Validation')
    plt.title('Model Accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Train')
    plt.plot(history.history['val_loss'], label='Validation')
    plt.title('Model Loss')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    plt.tight_layout()
    plt.savefig('mood_classifier_training_history.png')
    plt.show()

    # Evaluasi model pada test set
    test_loss, test_acc = model.evaluate(X_test, y_test, verbose=0)
    print(f"\nTest Accuracy: {test_acc:.4f}")
    print(f"Test Loss: {test_loss:.4f}")

    # Mendapatkan prediksi
    y_pred_prob = model.predict(X_test)
    y_pred = np.argmax(y_pred_prob, axis=1)

    # Menampilkan classification report
    print("\nClassification Report:")
    print(classification_report(y_test_raw, y_pred, target_names=list(label_mapping.values())))

    # Menampilkan confusion matrix
    plt.figure(figsize=(10, 8))
    cm = confusion_matrix(y_test_raw, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
               xticklabels=list(label_mapping.values()),
               yticklabels=list(label_mapping.values()))
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.title('Confusion Matrix')
    plt.tight_layout()
    plt.savefig('mood_classifier_confusion_matrix.png')
    plt.show()

    # Menyimpan model dan transformer jika diminta
    if save_model:
        # Simpan model
        model.save('mood_classifier_model')

        # Simpan encoder dan scaler
        import joblib
        joblib.dump(encoders['feature_scaler'], 'mood_feature_scaler.pkl')
        joblib.dump(encoders['label_encoder'], 'mood_label_encoder.pkl')
        joblib.dump(encoders['onehot_encoder'], 'mood_encoder.pkl')

        print("Model dan transformer telah disimpan.")

    return model, history

def evaluate_recommender_system(data_path, top_n=5, num_samples=10):
    """
    Mengevaluasi sistem rekomendasi makanan
    """
    # Memuat model rekomendasi
    import pickle
    try:
        with open('food_recommender.pkl', 'rb') as f:
            recommender = pickle.load(f)
    except:
        # Jika model belum ada, buat dan latih baru
        from food_recommendation_model import FoodRecommender
        recommender = FoodRecommender()
        recommender.load_data(data_path)
        recommender.save()

    # Memuat data makanan
    food_df = pd.read_csv(data_path)

    # Menampilkan distribusi mood dalam dataset
    plt.figure(figsize=(10, 6))
    mood_counts = food_df['primary_mood'].value_counts()
    sns.barplot(x=mood_counts.index, y=mood_counts.values)
    plt.title('Distribusi Mood dalam Dataset')
    plt.xlabel('Mood')
    plt.ylabel('Jumlah')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig('mood_distribution.png')
    plt.show()

    print("\nDistribusi Mood dalam Dataset:")
    for mood, count in mood_counts.items():
        print(f"{mood}: {count} ({count/len(food_df)*100:.2f}%)")

    # Evaluasi rekomendasi untuk setiap mood
    moods = ['energizing', 'relaxing', 'focusing']

    # Metrik evaluasi sederhana: kesamaan rekomendasi dengan mood yang diminta
    mood_accuracy = {}

    for mood in moods:
        print(f"\n=== Evaluasi Rekomendasi untuk Mood: {mood} ===")

        # Ambil rekomendasi untuk mood ini
        recommendations = recommender.recommend_for_mood(mood, top_n=top_n)

        # Hitung berapa rekomendasi yang sesuai dengan mood yang diminta
        if 'primary_mood' in recommendations.columns:
            correct = (recommendations['primary_mood'] == mood).sum()
            accuracy = correct / len(recommendations) * 100 if len(recommendations) > 0 else 0
            mood_accuracy[mood] = accuracy

            print(f"Accuracy: {accuracy:.2f}% ({correct}/{len(recommendations)} rekomendasi sesuai)")

            # Tampilkan beberapa contoh rekomendasi
            print("\nContoh Rekomendasi:")
            display_cols = ['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'primary_mood', 'similarity_score']
            display_cols = [col for col in display_cols if col in recommendations.columns]
            print(recommendations[display_cols].head(min(3, len(recommendations))))
        else:
            print("Kolom 'primary_mood' tidak ditemukan dalam rekomendasi")

    # Visualisasi akurasi rekomendasi
    plt.figure(figsize=(10, 6))
    sns.barplot(x=list(mood_accuracy.keys()), y=list(mood_accuracy.values()))
    plt.title('Akurasi Rekomendasi Berdasarkan Mood')
    plt.xlabel('Mood')
    plt.ylabel('Akurasi (%)')
    plt.ylim(0, 100)
    plt.tight_layout()
    plt.savefig('recommender_accuracy.png')
    plt.show()

    # Evaluasi dengan kondisi kesehatan
    health_conditions = ['diabetes', 'hipertensi', 'kolesterol']

    print("\n=== Evaluasi Rekomendasi dengan Kondisi Kesehatan ===")

    for condition in health_conditions:
        print(f"\nKondisi Kesehatan: {condition}")

        # Ambil rekomendasi dengan kondisi kesehatan
        recommendations = recommender.recommend_for_mood('energizing', top_n=top_n, health_conditions=[condition])

        # Tampilkan contoh rekomendasi
        print("Contoh Rekomendasi:")
        display_cols = ['name', 'calories', 'proteins', 'fat', 'carbohydrate', 'similarity_score']
        display_cols = [col for col in display_cols if col in recommendations.columns]
        print(recommendations[display_cols].head(min(3, len(recommendations))))

def main():
    """
    Fungsi utama untuk pelatihan dan evaluasi model
    """
    # Path dataset
    data_path = 'nutrimood_preprocessed.csv'

    # 1. Load dan preprocess data
    print("=== MEMUAT DAN MEMPROSES DATA ===")
    data = load_and_preprocess_data(data_path)

    # 2. Latih dan evaluasi model mood classifier
    print("\n=== MELATIH DAN MENGEVALUASI MODEL MOOD CLASSIFIER ===")
    model, history = train_and_evaluate_model(data)

    # 3. Evaluasi sistem rekomendasi
    print("\n=== MENGEVALUASI SISTEM REKOMENDASI ===")
    evaluate_recommender_system(data_path)

    print("\n=== PELATIHAN DAN EVALUASI SELESAI ===")

if __name__ == "__main__":
    main()